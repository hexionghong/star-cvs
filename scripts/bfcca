#!/usr/local/bin/perl

#
# This script will be developped as a unique flexible
# back-end to the CRS software. Options passed to this
# script will specify ALL of what we need to run a chain,
# many chains, any destinations, with any library version.
#
# This one script may therefore handle multiple production.
# 
# Written J.Lauret July 2001.
# Please, follow comments for more information ...
#
#  Some info :
#  The job descriptor should be as follow
#    executable=ThisProgram
#    executableargs=LibraryVersion,Destination,NumEvt,options...
#
#  where
#   LibraryVersion can be one of new, dev, old, pro or a version
#                  understood by 'starver'
#   Destination    is a disk-path used for file copy.
#   Numevt         the number of events to process. -1 or 0 means
#                  a large number.
#   Options        as many comma separated options. They will all
#                  go as bfc chain options.
#
# There are 2 cases where the Destination field is used
#
# 1 - In outputstreamtype=HPSS, the file is therefore copied
#     on disk before the CRS software takes care of staging the
#     output onto HPSS.
# 2 - The outputstreamtype=UNIX has been chose __AND__ the
#     stdoutdir was specified as ./ . This will automatically
#     trigger a copy of the local output to the destination.
#

use File::Basename;
use File::Copy;


# First of all, turn IO autoflush
$|       = 1; 


# Some default hardwired values
$HPSSBASE= "/home/starreco";       # base HPSS path
$NTRIES  = 720;                    # number of tries -1 means infinit tries
$SLPTIME = 120;                    # sleep time in sec between mkpath attempts
$PRGM    = "bfcca";                # this program logical name 


# This is for debugging purposes
#print "Dumping passed values at startup time\n";
#for($i=0 ; $i <= $#ARGV ; $i++){
#  print "$i -> $ARGV[$i]\n";
#}
#foreach $el (keys %ENV){
#   print "$el -> $ENV{$el}\n";
#}
#print "We are now in business ...\n";
#print `ls -l`;


# The first element of the argument list
# is rather of unknown usage. It is always
# 0. Afterward, this script accept (in order
# it receives)
shift @ARGV;
$LIBRARY     = shift @ARGV;
$DESTINATION = shift @ARGV;
$NUMEVT      = shift @ARGV;
$CHAINOPT    = join(" ",@ARGV);

#
# The CRS software sets up environment variables
# according to the job description file. If a file
# is of type HPSS, the ACTUAL_XXX would refer to
# the file as restored on local disk while the XXX
# would refere to the initial file name (as per in HPSS)
#
for($i =0 ; ; $i++){
    eval('$in = $ENV{"ACTUAL_INPUT$i"}');
    if( ! defined($in) ){ last;}
    eval('$cin = $ENV{"INPUT$i"}');
    if( ! defined($cin) ){ last;}
    push(@CINPUTS,$cin);	
    push(@INPUTS,$in);	
} 


# The first one is used as our input stream, the rest are
# subject to chain options.
# If something else needs to be done for the other input files
# (like adding to the chain option), please, add code with backward
# compatibility possibility. I think this code is suitable for pp
# gstar options modulo this implementation.
$INPUTFILE  = shift @INPUTS;
$CINPUTFILE = shift @CINPUTS;


#
# Other input files may be options
#
foreach $file (@CINPUTS){
    if( $file =~ /StarDb/){
	# Calibration run enabled. Create soft link.
	$file = dirname($file);
	symlink($file,"StarDb");
    }
    #} elsif etc ...
}


# The number of output files is unknown but we can evaluate
# this. This loop may also be used for
for($i =0 ; ; $i++){
    eval('$cout  = $ENV{"OUTPUT$i"}');
    if( ! defined($cout)  ){ last;}      
    eval('$out = $ENV{"ACTUAL_OUTPUT$i"}');
    if( ! defined($out) ){ last;}
    push(@COUTPUTS,$cout);
    push(@OUTPUTS,$out);	
} 



# Take this as well for later use.
$JOB_ID= $ENV{"CRS_JOB_ID"};
$PWD   = $ENV{"PWD"};



#
# Fix default values, check sanity
#
# num events default value
if( $NUMEVT <= 0){ $NUMEVT = 10000;}
# Simplify library version change (commodity)
if($LIBRARY =~ m/dev/i || $LIBRARY =~ m/new/i || 
   $LIBRARY =~ m/pro/i || $LIBRARY =~ m/old/i){
   $CHVER = "star".lc($LIBRARY);
} else {
   $CHVER = "starver $LIBRARY";
}
if($INPUTFILE eq ""){
    print STDERR "$PRGM :: Error: no input file specified\n";
    exit;
} else {
    # Extension check. Out chain requires a .daq extension.
    $ext = $CINPUTFILE;
    $ext =~ s/.*\.//g;
    #print "Debug:: [$ext]\n";
    if($ext eq "" || $ext eq $CINPUTFILE){
	# An HPSS file was restored. We need to create
	# a symlink with a .daq name and use this as
	# our input.
	$tmp = basename($INPUTFILE);
	symlink($CINPUTFILE,$tmp);
	$CINPUTFILE = $tmp;
    }
}




print "Our job ID                       $JOB_ID\n";
print "Out working directory            $PWD\n";
print "The chain will run from library  $LIBRARY\n";
print "The chain will run with options  $CHAINOPT\n";
print "The output destination will be   $DESTINATION\n";
print "The number of events would be    $NUMEVT\n";
print "The chain will run over file     $INPUTFILE\n";
print "This file is stored as           $CINPUTFILE\n";
print "Outputs initial will be          ".join(" ",@COUTPUTS)."\n";
print "Outputs final will be            ".join(" ",@OUTPUTS)."\n";



# Now, we are ready to go ... What we will do is to create
# a local csh file containing all of the required commands
# and loading. Peffered shell will be csh (available on ALL
# flavor of Unix) rather than tcsh which needs to be installed.
if ( ! open(FO,">$PWD/$JOB_ID.csh") ){
    print STDERR "$PRGM :: Failure to open a temporary file $!\n";
} else {
    # Note that we will be able to dup STDOUT STDERR to a file later
    # (and if required) as well as writing handler routine to prevent
    # from a crash.
    print FO 
	"#!/bin/csh\n",
	"setenv GROUP_DIR /afs/rhic/rhstar/group\n", # default GROUP_DIR
	"source \$GROUP_DIR/star_login.csh\n",       # load basic login env
	"unset noclobber\n",                         # over-write
	"$CHVER\n",                                  # load chosen library env
	"echo \"Executing \`which root4star\`\"\n",  # some info/debug message
	"root4star -b -q 'bfc.C($NUMEVT,\"$CHAINOPT\",\"$CINPUTFILE\")'\n";
	
	

    close(FO);
    chmod(0755,"$PWD/$JOB_ID.csh");


    &List("Our working directory contains","We will now start to run ...");

    system("$PWD/$JOB_ID.csh");
   
    # after this, we may have crashed or not
    if($! == 0){
	print "$PRGM :: Info: The chain as completed without failure\n";
    } else {
	print STDERR "$PRGM :: Error: chain stopped with status [$!]\n";
    }
   
    &List("The directory content is now ...");

    
   
    # But please, do not stop there but move the output if required
    # Required means that the option was HPSS, UNIX option means
    # that it will be written over NFS so we do not need to move the
    # file. We can recognize the difference because the $cfile is
    # different than the $file in HPSS mode and identical in NFS mode.
    for($i=0 ; $i <= $#COUTPUTS ; $i++){
	$cfile = $COUTPUTS[$i];

	if( -e $cfile){
	    $file  = $OUTPUTS[$i];
	    $ffile = "";
	
	    if( $file ne $cfile){
		# Massage the substitution. This is a HPSS file
		# cloned/copied to a disk as well.
		$ffile = $file;              
		$ffile =~ s|$HPSSBASE|$DESTINATION|;
	    } elsif ( dirname($file) eq "."){
		# This is a file left on the local disk we want 
		# to move now.
		$ffile = $file;
		$ffile =~ s|./|$DESTINATION/|;
	    } 
      
      
	    # OK to copy -> $ffile is defined
	    if( $ffile ne ""){
		# Get the directory name
		$dir  = dirname($ffile);
		# create directory all the way up but also, try multiple times
		# if it fails.
		$k    = 0;
	      CREATE_DIR:
		if( MkPath($dir,2) != 1){
		    print "$PRGM :: Info: Failed to create $dir on ".localtime()."\n";
		    $k++;
		    if($k != $NTRIES){ 
			sleep($SLPTIME);
			goto CREATE_DIR;
		    } else {
			print STDERR "$PRGM :: Error: Failed to create path $dir\n";
		    }
		}
	   
		# if the final file already exists, remove it first
		if( -e $ffile){ unlink($ffile);}
		# OK, the target directory is created, no other file exist with
		# that name ... Copy the file now.
		print "$PRGM :: Info: Copying $cfile -> $ffile\n";
		copy($cfile,$ffile);
		if( ! -e $ffile){
		    print "$PRGM :: Warning: Action did not create $ffile\n";
		}
	      
	    } else {
		print "$PRGM :: Info: $file is at its final destination\n";
	    }
	
	} else {
	    # Oups ! The output file was not found
	    print "$PRGM :: Warning: action did not produce expected $cfile\n";
	}	
    }
    print "$PRGM :: Info: All output checked. Done.\n";
}



#
# Subroutine to check and create path. mkpath()
# in the perl module does not return the failure
# reasons and do not implement special cases as
# we do. So, screw it ...
#
sub MkPath
{
    my($dir,$level)=@_;
    my(@items,$tmp,$el,$i);
   
    # default
    if( ! defined($level) ){ $level = 0;}
   
    @items = split("/",$dir);
    shift(@items);               # strip first blank space
    $tmp = "";
    $i   = 0;
    foreach $el (@items){
	$tmp .= "/$el";
	$i++;
	if( ! -d $tmp){
	    # oupses !! file exists with same name than directory. 
	    # This is a non-no in Uglix-land.
	    if (-f $tmp){  
		print STDERR "$PRGM :: Error: Cannot create dir $tmp. File exists with the same name.\n";
		return -1;
	    }

	    # we can even test where this fails ...
	    # The level variable is used to prevent frm accidental directory creation
	    # in case of disk unmount. For example, level = 2 will prevent creation
	    # before a /star/dataXX directory ...
	    if($i >= $level){
		if( ! mkdir($tmp,0773) ){
		    print STDERR "$PRGM :: Error: Failed to create $tmp [$!]\n";
		    return -2;
		}
	    }
	}
    }
    1;
}


#
# Small common routine for doing a ls/directory
# content (helps for debugging purposes).
#
sub List
{
    my($smess,$emess)=@_;
    my($i);

    for($i=0 ; $i < 45 ; $i++){ print "-=";}
    print "\n";
    print "$PRGM :: Info: $smess\n" if ( defined($smess) );
    print `ls -l`;
    print "$PRGM :: Info: $emess\n" if ( defined($emess) );    
    for($i=0 ; $i < 45 ; $i++){ print "-=";}
    print "\n";
}
