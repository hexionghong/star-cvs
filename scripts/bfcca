#!/usr/local/bin/perl

#
# This script will be developped as a unique flexible
# back-end to the CRS software. Options passed to this
# script will specify ALL of what we need to run a chain,
# many chains, any destinations, with any library version.
#
# This one script may therefore handle multiple production.
# 
# Written J.Lauret July 2001.
# Please, follow comments for more information ...
#
#  Some info :
#  The job descriptor should be as follow
#    executable=ThisProgram
#    executableargs=LibraryVersion,Destination,NumEvt,options...
#
#  where
#   LibraryVersion can be one of new, dev, old, pro or a version
#                  understood by 'starver'
#   Destination    is a disk-path used for file copy.
#   Numevt         the number of events to process. -1 or 0 means
#                  a large number.
#   Options        as many comma separated options. They will all
#                  go as bfc chain options.
#
# There are 2 cases where the Destination field is used
#
# 1 - In outputstreamtype=HPSS, the file is therefore copied
#     on disk before the CRS software takes care of staging the
#     output onto HPSS.
# 2 - The outputstreamtype=UNIX has been chose __AND__ the
#     stdoutdir was specified as ./ . This will automatically
#     trigger a copy of the local output to the destination.
#

use File::Basename;
use File::Copy;


# First of all, turn IO autoflush
$|       = 1; 


# Some default hardwired values
$HPSSBASE= "/home/starreco";       # base HPSS path
$NTRIES  = 10;                     # number of tries
$SLPTIME = 60;                     # sleep time in sec between mkpath
$MASK    = "0773";                 # default mask for dir creation.
$PRGM    = "bfcca";                # this program logical name 


# This is for debugging purposes
print "Dumping passed values at startup time\n";
for($i=0 ; $i <= $#ARGV ; $i++){
  print "$i -> $ARGV[$i]\n";
}
foreach $el (keys %ENV){
   print "$el -> $ENV{$el}\n";
}
print "We are now in business ...\n";


# The first element of the argument list
# is rather of unknown usage. It is always
# 0. Afterward, this script accept (in order
# it receives)
shift @ARGV;
$LIBRARY     = shift @ARGV;
$DESTINATION = shift @ARGV;
$NUMEVT      = shift @ARGV;
$CHAINOPT    = join(" ",@ARGV);

#
# The CRS software sets up environment variables
# according to the job description file. If a file
# is of type HPSS, the ACTUAL_XXX would refer to
# the file as restored on local disk while the XXX
# would refere to the initial file name (as per in HPSS)
#
for($i =0 ; ; $i++){
   eval('$in = $ENV{"ACTUAL_INPUT$i"}');
   if( ! defined($in) ){ last;}
   push(@INPUTS,$in);	
} 


# The first one is used as our input stream, the rest are
# subject to chain options.
# If something else needs to be done for the other input files
# (like adding to the chain option), please, add code with backward
# compatibility possibility. I think this code is suitable for pp
# gstar options modulo this implementation.
$INPUTFILE = shift @INPUTS;




# The number of output files is unknown but we can evaluate
# this. This loop may also be used for
for($i =0 ; ; $i++){
   eval('$cout = $ENV{"ACTUAL_OUTPUT$i"}');
   if( ! defined($cout) ){ last;}
   eval('$out  = $ENV{"OUTPUT$i"}');
   if( ! defined($out)  ){ last;}      # but this should not happen
   push(@COUTPUTS,$cout);
   push(@OUTPUTS,$out);	
} 



# Take this as well for later use.
$JOB_ID= $ENV{"CRS_JOB_ID"};
$PWD   = $ENV{"PWD"};



#
# Fix default values, check sanity
#
# num events default value
if( $NUMEVT <= 0){ $NUMEVT = 9999999999;}
# Simplify library version change (commodity)
if($LIBRARY =~ m/dev/i || $LIBRARY =~ m/new/i || 
   $LIBRARY =~ m/pro/i || $LIBRARY =~ m/old/i){
   $CHVER = "star".lc($LIBRARY);
} else {
   $CHVER = "starver $LIBRARY";
}


print "Our job ID                       $JOB_ID\n";
print "The chain will run from library  $LIBRARY\n";
print "The chain will run with options  $CHAINOPT\n";
print "The output destination will be   $DESTINATION\n";
print "The number of events would be    $NUMEVT\n";
print "The chain will run over file     $INPUTFILE\n";
print "Outputs initial will be          ".join(" ",@COUTPUTS)."\n";
print "Outputs final will be            ".join(" ",@OUTPUTS)."\n";





# Now, we are ready to go ... What we will do is to create
# a local csh file containing all of the required commands
# and loading. Peffered shell will be csh (available on ALL
# flavor of Unix) rather than tcsh which needs to be installed.
if ( ! open(FO,">$PWD/$JOB_ID.csh") ){
   print STDERR "$PRGM :: Failure to open a temporary file $!\n";
} else {
   # Note that we will be able to dup STDOUT STDERR to a file later
   # (and if required) as well as writing handler routine to prevent
   # from a crash.
   print FO 
   	"#!/bin/csh\n",
	"cat \$0\n",
	"setenv GROUP_DIR /afs/rhic/rhstar/group\n", # default GROUP_DIR
	"source \$GROUP_DIR/star_login.csh\n",       # load basic login env
	"$CHVER\n",                                  # load chosen library env
	"echo \"Hello World\" >$OUTPUTS[0]\n",       # test 
	"echo \"Executing \`which root4star\`\"\n",  # some info/debug message
	"# root4star -b -q 'bfc.C(\"$NUMEVT\",\"$CHAINOPT\",\"$INPUTFILE\")'\n";
	
	

   close(FO);
   chmod(0755,"$PWD/$JOB_ID.csh");
   system("$PWD/$JOB_ID.csh");
   
   # after this, we may have crashed or not
   if($! == 0){
      print "$PRGM :: Info: The chain as completed without failure\n";
   } else {
      print STDERR "$PRGM :: Error: chain stopped with status [$!]\n";
   }
   
   
   # But please, do not stop there but move the output if required
   # Required means that the option was HPSS, UNIX option means
   # that it will be written over NFS so we do not need to move the
   # file. We can recognize the difference because the $cfile is
   # different than the $file in HPSS mode and identical in NFS mode.
   for($i=0 ; $i <= $#COUTPUTS ; $i++){
      $cfile = $COUTPUTS[$i];

      if( -e $cfile){
        $file  = $OUTPUTS[$i];
        $ffile = "";
	
        if( $file ne $cfile){
	 # Massage the substitution. This is a HPSS file
	 # cloned/copied to a disk as well.
	 $ffile = $file;              
	 $ffile =~ s|$HPSSBASE|$DESTINATION|;
        } elsif ( dirname($file) eq "."){
         # This is a file left on the local disk we want 
	 # to move now.
	 $ffile = $file;
	 $ffile =~ s|./|$DESTINATION/|;
        } 
      
      
        # OK to copy -> $ffile is defined
        if( $ffile ne ""){
          # Get the directory name
	  $dir  = dirname($ffile);
	  # create directory all the way up but also, try multiple times
	  # if it fails.
	  $k    = 0;
	  CREATE_DIR:
	   if( MkPath($dir,2) != 1){
	       print STDERR "$PRGM :: Error: Failed to create $dir on ".localtime()."\n";
	       $k++;
	       if($k < $NTRIES){ 
	          sleep($SLPTIME);
	          goto CREATE_DIR;
	       }
	   }
	   
	  # if the final file already exists, remove it first
	  if( -e $ffile){ unlink($ffile);}
	  # OK, the target directory is created, no other file exist with
	  # that name ... Copy the file now.
	  print "$PRGM :: Info: Copying $cfile -> $ffile\n";
	  copy($cfile,$ffile);
	  if( ! -e $ffile){
	     print "$PRGM :: Warning: Action did not create $ffile\n";
	  }
	 	 
        } else {
	  print "$PRGM :: Info: $file is at its final destination\n";
	}
	
      } else {
        # Oups ! The output file was not found
	print STDERR "$PRGM :: Warning: action did not produce expected $cfile\n";
      }	
   }
   print "$PRGM :: Info: All output checked. Done.\n";
}



#
# Subroutine to create path. mkpath()
# in the perl module does not return the failure
# reasons and do not implement special cases as
# we do. So, screw it ...
#
sub MkPath
{
   my($dir,$level)=@_;
   my(@items,$tmp,$el,$i);
   
   # default
   if( ! defined($level) ){ $level = 0;}
   
   @items = split("/",$dir);
   shift(@items);               # strip first blank space
   $tmp = "";
   $i   = 0;
   foreach $el (@items){
      $tmp .= "/$el";
      $i++;
      if( ! -d $tmp){
         # oupses !! file exists with same name than directory. 
	 # This is a non-no in Uglix-land.
         if (-f $tmp){  
	    print STDERR "$PRGM :: Error: Cannot create dir $tmp. File exists with the same name.\n";
	    return -1;
	 }

         # we can even test where this fails ...
	 # The level variable is used to prevent frm accidental directory creation
	 # in case of disk unmount. For example, level = 2 will prevent creation
	 # before a /star/dataXX directory ...
	 if($i >= $level){
           if( ! mkdir($tmp,$MASK) ){
             print STDERR "$PRGM :: Error: Failed to create $tmp\n";
             return -2;
           }
	 }
      }
    }
    1;
}



