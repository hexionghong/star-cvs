#! /opt/star/bin/perl
# Ben Norman (11jun2000)

# CGI gateway program for AutoQA (CGI_gateway)
#
# CGI_gateway is a CGI script which collects all the environment information
# given by the web server (variables & stdin), then invokes QA_main.pm
# on an rcas computer and returns QA_main's output to the
# web server as stdout.
#
# One should ensure that the user running CGI_gateway (starlib) has afs
# tokens on both the web server (sol) and the target host (rcas6001).
#
# Actual communication with RCAS is done using shared afs filespace.  
# CGI_gateway drops a file in this area, a script to run QA_main.pm and
# set up the CGI environment variables.  A daemon on RCAS
# polls for such files and runs the script.  It then places the output of that
# script in a second file, which CGI_gateway polls for.  This convoluted
# approach imparts some delay to the process, but it is much better than 5-10
# seconds for a double ssh jump from sol to rcas via rsshgw.

use strict;
use Cwd;
use FileHandle;

my $my_name = "CGI_gateway";
my $working_dir = cwd();
my $scratch_dir = "/afs/rhic/star/starqa/scratch";
my $script_name = "$scratch_dir/$my_name.$$";
my $output_name = "$script_name.output";
my $target_program = "QA_main.pm";
my $afs_pw_file = "$working_dir/starlib_pw";

my $scriptFH = new FileHandle;

# don't buffer output
\*STDOUT->autoflush(1);
\*STDERR->autoflush(1);

#
# check for reauth running for starlib on sol and restart it if
# necessary.  reauth refreshes afs tokens automatically, and we
# need a token before we can write to afs space.
#

my $reauth = `ps -u starlib | grep reauth`;
if (! $reauth) {
    my $cmd = "/usr/afsws/bin/reauth 85000 starlib `cat $afs_pw_file`";
    system ($cmd);
}

#
# Open the batch script
#

$scriptFH->open(">$script_name");
print $scriptFH "#!/usr/local/bin/tcsh\n";

#
# Dump the environment variables to the script
#

# should make rcas (linux) friendly path
$ENV{PATH} = $ENV{PATH} . 
	":.:/bin:/usr/local/bin:/usr/bin:/usr/afsws/bin:/usr/local/lsf/bin";

print $scriptFH "\n# set up the CGI environment\n";
foreach my $env_var (keys (%ENV)){
    my $env_string = $ENV{$env_var};
    # escape all the nasty things with octal rep
    $env_string =~ s/([\`\'\"{}!\@\$*?\n\r])/&charToOct($1)/ge;
    print $scriptFH "setenv $env_var \"$env_string\"\n";
}

#
# Print out the target program invocation, providing stdin as a HERE doc 
#

print $scriptFH "\n# Invoke the target program\n";
print $scriptFH "cd $working_dir\n";
print $scriptFH "./$target_program <<MICA\n";

while (<STDIN>){
    print $scriptFH $_;
}

print $scriptFH "MICA\n";
undef $scriptFH;
chmod 0755, $script_name;  # make executable

#
# Now poll the afs filespace for the output file
#

while (! -s $output_name){  # while not nonzero size
    sleep 1;
}

my @output = `cat $output_name`;
print @output;

#
# Clean up
#

unlink $output_name;
#system ("mv $output_name $scratch_dir/old");
exit 0;


#
# returns an octal string representation (\0nnn) for the given character
#

sub charToOct{
    my $char = shift;
    
    my $char = unpack("C", $char); # now a decimal number
    my $oit2 = ($char & 0700) >> 6; # oit = Octal digIT ;)
    my $oit1 = ($char & 0070) >> 3;
    my $oit0 = ($char & 0007);

    return "\\0$oit2$oit1$oit0";
}






