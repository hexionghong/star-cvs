#! /opt/star/bin/perl
# Ben Norman (11jun2000)

# CGI gateway program for AutoQA (CGI_gateway)
#
# CGI_gateway is a CGI script which collects all the environment information
# given by the web server (variables & stdin), then creates a script to 
# invoke an arbitrary program (default QA_main.pm) on an rcas computer.  It
# then waits for the CGI_dispatcher daemon running on rcas to execute the 
# script and write the output to a file.
#
# The program ensures that the user running CGI_gateway (starlib) has an afs
# token on the web server (sol).  CGI_disp
#
# Actual communication with RCAS is done using shared afs filespace.  
# CGI_gateway drops a file in this area, a script to run QA_main.pm and
# set up the CGI environment variables.  A daemon on RCAS
# polls for such files and runs the script.  It then places the output of that
# script in a second file, which CGI_gateway polls for.  This convoluted
# approach imparts some delay to the process, but it is much better than 5-10
# seconds for a double ssh jump from sol to rcas via rsshgw.
#
# Usage:  http://myserver/mydir/CGI_gateway?targetProgram=<target program>&
#                                     workingDirectory=<working directory>
#
# <working directory> is the directory the target program should be run from,
#                     defaults to the running directory of CGI_gateway.
#                     This is given in the target computer file-space.
# <target program> is the invocation of the target program, relative to
#                  the working directory.  Keep in mind that this should be
#                  a cgi program, i.e., one returning good http headers!
#

use strict;
use Cwd;
use FileHandle;

my $my_name = "CGI_gateway";
my $working_dir = cwd();
my $scratch_dir = "/afs/rhic/star/starqa/scratch";
my $script_name = "$scratch_dir/$my_name.$$";
my $output_name = "$script_name.output";
my $target_program = "QA_main.pm";
my $afs_pw_file = "$working_dir/starlib_pw";

my $scriptFH = new FileHandle;

# don't buffer output
\*STDOUT->autoflush(1);
\*STDERR->autoflush(1);

#
# check for reauth running for starlib on sol and restart it if
# necessary.  reauth refreshes afs tokens automatically, and we
# need a token before we can write to afs space.
#

my $reauth = `ps -u starlib | grep reauth`;
if (! $reauth) {
    my $cmd = "/usr/afsws/bin/reauth 85000 starlib `cat $afs_pw_file`";
    system ($cmd);
}

#
# determine non-default target program and/or working directory,
# don't use CGI.pm to avoid messing up environment vars
#

my $queryString = $ENV{QUERY_STRING};
if ($queryString =~ /targetProgram=([^&]*)/){
    $target_program = $1;
}
if ($queryString =~ /workingDirectory=([^&]*)/){
    $working_dir = $1;
}

#
# Open the batch script
#

$scriptFH->open(">$script_name");
print $scriptFH "#!/usr/local/bin/tcsh\n";

#
# Dump the environment variables to the script
#

# should make rcas (linux) friendly path
$ENV{PATH} = $ENV{PATH} . 
	":.:/bin:/usr/local/bin:/usr/bin:/usr/afsws/bin:/usr/local/lsf/bin";

print $scriptFH "\n# set up the CGI environment\n";
foreach my $env_var (keys (%ENV)){
    my $env_string = $ENV{$env_var};
    # escape all the nasty things with octal rep
    $env_string =~ s/([\`\'\"{}!\@\$*?\n\r])/&charToOct($1)/ge;
    print $scriptFH "setenv $env_var \"$env_string\"\n";
}

#
# Print out the target program invocation, providing stdin as a HERE doc 
#

print $scriptFH "\n# Invoke the target program\n";
print $scriptFH "cd $working_dir\n";
print $scriptFH "$target_program <<MICA\n";  # '.' is in the path

while (<STDIN>){
    print $scriptFH $_;
}

print $scriptFH "MICA\n";
undef $scriptFH;
chmod 0755, $script_name;  # make executable

#
# Now poll the afs filespace for the output file
#

while (! -s $output_name){  # while not nonzero size
    sleep 1;
}

my @output = `cat $output_name`;
print @output;

#
# Clean up
#

unlink $output_name;
exit 0;


#
# returns an octal string representation (\0nnn) for the given character
#

sub charToOct{
    my $char = shift;
    
    my $char = unpack("C", $char); # now a decimal number
    my $oit2 = ($char & 0700) >> 6; # oit = Octal digIT ;)
    my $oit1 = ($char & 0070) >> 3;
    my $oit0 = ($char & 0007);

    return "\\0$oit2$oit1$oit0";
}






