#!/usr/bin/perl

# LSF_tool provides a cgi interface to the lsf commands bjobs,
# bhist and bkill, bstop, bresume, peek.
#
# BEN(20jun2000)
#
# some semantics:  
#   "selected" jobs are those which are selected by 
#              attribute in the browser and returned to the user
#   "marked"   jobs are those which the user has chosen from among
#              the "selected" jobs using checkboxes
#
# To do:  perhaps encapsulate a "job" in an object with fields given by
# @$selectionKeys, and methods corresponding to the actions.

use strict;
use CGI;

my $expertMode = 0;

#
# the keys and headings used in the various selection columns
#

my $selectionKeys = [
		     "jobID",
		     "user",
		     "status",
		     "queue",
		     "fromHost",
		     "execHost",
		     "jobName",
		     "submitTime"
		     ];
my $selectionLabels = [
		       "Job ID",
		       "User",
		       "Status",
		       "Queue",
		       "Submitted From",
		       "Executed On",
		       "Job Name",
		       "Submit Time"
		       ];

my $cgi = new CGI;

# don't buffer output
$| = 1;

# handle dead kids
$SIG{CHLD} = 'reaper';

# print out the beginning of the document
print startDocument($cgi);

# carry out any action requested by the user and print result to new window
print performAction($cgi);

print controlButtons($cgi);

# we need the lsf job information before printing the job table, but
# we don't want to call bjobs until after actions have been performed
my $jobs = bJobs();  # reference to hash (by jobID) of references to hashes

# print out the table which includes job selection controls and
# the selected jobs
print $cgi->table({-border=>1},
		  $cgi->Tr(
			   {-align=>"CENTER",-valign=>"TOP"},
			   selectionHeadings($cgi)
			   ) . "\n",
		  selectionControls($cgi, $jobs) . "\n",
		  selectedJobs($cgi, $jobs) . "\n"
		  ) . "\n";

print endDocument($cgi);

exit 0;

#
# return the control buttons for acting on the jobs
#

sub controlButtons{
    my $cgi = shift;

    my $text = "<br><b>View marked jobs:</b>\n";
    
    $text .= $cgi->submit(-name=>'action',
			  -value=>'Details') . "\n";
    $text .= $cgi->submit(-name=>'action',
			  -value=>'History') . "\n";
    $text .= $cgi->submit(-name=>'action',
			  -value=>'Peek') . "\n";

    # show modification buttons, or expert password prompt
    if ($expertMode){
	$text .= "<br><b>Edit marked jobs ".
	    "<font color=red>(Expert Mode)</font>:</b>\n";
	
	$text .= $cgi->hidden(-name=>'expertPW',
			      -value=>$cgi->param("expertPW")) . "\n";
	$text .= $cgi->submit(-name=>'action',
			      -value=>'Suspend') . "\n";
	$text .= $cgi->submit(-name=>'action',
			      -value=>'Resume') . "\n";
	$text .= $cgi->submit(-name=>'action',
			      -value=>'Kill') . "\n";
    }else{
	$text .= "<br><b>Enter expert password to modify jobs:</b>\n";

	$text .= $cgi->password_field(-name=>'expertPW',
				      -size=>8,
				      -maxlength=>8) . "\n";
	$text .= $cgi->submit(-name=>'action',
			      -value=>'Expert Mode') . "\n";
    }

    $text .= "<br>\n";

    $text .= $cgi->submit(-value=>'Refresh Job List') . "\n";

    $text .= "<br>\n";

    return $text;
}

#
# return the title headings w/ sort buttons for the job table
#

sub selectionHeadings{
    my $cgi = shift;
    my $text = $cgi->td();

    # get a set of radio buttons to select the field to sort on
    my $radioButtons = [$cgi->radio_group(
					  -name=>'sortField',
					  -value=>$selectionKeys,
					  -default=>'jobID',
					  -nolabels=>1,
					  -onClick=>'this.form.submit()'
					  ) ];

    for(my $num = 0; $num <= $#$selectionKeys; $num++){
	$text .= $cgi->td(
			  {-bgcolor=>'yellow'},
			  $selectionLabels->[$num] .
			  "<br>\n(" . $radioButtons->[$num] . " sort)"
			  );
    }

    return $text;
}

#
# return the controls for selecting jobs by attribute
#

sub selectionControls{
    my $cgi = shift;
    my $jobs = shift;
    
    # get the possible choices for each field based on the current jobs
    my $fieldChoices = getFieldChoices($cgi, $jobs);

    # column selection controls
    my $text = "";
    $text .= $cgi->Tr(
		$cgi->td(
			 {-bgcolor=>'pink'},
			 "Mark Jobs"
			 ) . 
	        $cgi->td(
			 {-bgcolor=>'lightblue'},
			 [map({ 
			     $cgi->popup_menu( 
					       -name=>$_,
					       -values=>$fieldChoices->{$_},
					       -default=>"any",
					       -onchange=>"this.form.submit()"
					       )
			     } @$selectionKeys)
			  ])
		      ) . "\n";
    
    return $text;
}

#
# return the selected jobs, one per table row
#

sub selectedJobs{
    my $cgi = shift;
    my $jobs = shift;

    # get the jobs meeting the selection criteria
    my @selectedJobs = ();
    my @selectedJobIDs = ();
    
    if (jobsSelected($cgi)){   # jobs have been limited in some way
      JOB_LOOP: foreach my $job (values %$jobs){
	  foreach my $key (@$selectionKeys){
	      if ($cgi->param($key) ne "" &&  # if no match to specified value
		  $cgi->param($key) ne "any" &&
		  $cgi->param($key) ne $job->{$key}){
		  next JOB_LOOP;
	      }
	  }
	  # matches all necessary criteria, add it
	  push @selectedJobs, $job;
      }
    }else{                     # show all jobs
	@selectedJobs = values %$jobs;
    }

    # sort the jobs based on the sortField parameter
    my $sortKey = $cgi->param('sortField');
    $sortKey or $sortKey = "jobID";   # first call, sort on job id
    @selectedJobs = sort {$a->{$sortKey} cmp $b->{$sortKey}} @selectedJobs;
    for (my $i = 0; $i <= $#selectedJobs; $i++){
	$selectedJobIDs[$i] = $selectedJobs[$i]->{"jobID"};
    }

    # get a set of checkboxes to select the rows (jobs)
    my @checkBoxes = $cgi->checkbox_group(
					  -name=>'markedJobs',
					  -value=>[@selectedJobIDs],
					  -nolabels=>1
					  );

    # generate the table text, one row per job
    my $text = "";
    for (my $i = 0; $i <= $#selectedJobs; $i++){
	$text .= $cgi->Tr(
			  $cgi->td(
				   {-bgcolor=>'pink'},
				    $checkBoxes[$i]
				   ) . 
			  $cgi->td([
				    map(
					{ $selectedJobs[$i]->{$_} } 
					@$selectionKeys)
				    ]) . "\n"
			  ) . "\n";
    }
    
    return $text;
}

#
# perform any action requested by the user and send the output to a new
# window
#

sub performAction{
    my $cgi = shift;

    my $action = $cgi->param("action");
    my @markedJobIDs = $cgi->param("markedJobs");

    # is the user an expert?
    if ($cgi->param("expertPW") eq "qaexpert"){
	$expertMode = 1;
    }

    my $text = "";
    if($action eq "Details"){
	foreach my $jobID (@markedJobIDs){
	    writeToNewWindow($cgi->h3("Details for Job $jobID") . "\n" .  
			     $cgi->pre(@{runLSFCmd("bjobs -l $jobID 2>&1")}) .
			     "\n");
	}
    }elsif($action eq "History"){
	foreach my $jobID (@markedJobIDs){
	    writeToNewWindow($cgi->h3("History for Job $jobID") . "\n" . 
			     $cgi->pre(@{runLSFCmd("bhist -l $jobID 2>&1")}) .
			     "\n");
	}
    }elsif($action eq "Kill"){
	foreach my $jobID (@markedJobIDs){
	    writeToNewWindow($cgi->h3("Killing Job $jobID") . "\n" . 
			     $cgi->pre(@{runLSFCmd("bkill $jobID 2>&1")}) . 
			     "\n");
	}
    }elsif($action eq "Suspend" && $expertMode){
	foreach my $jobID (@markedJobIDs){
	    writeToNewWindow($cgi->h3("Suspending Job $jobID") . "\n" .  
			     $cgi->pre(@{runLSFCmd("bstop $jobID 2>&1")}) . 
			     "\n");
	}
    }elsif($action eq "Resume" && $expertMode){
	foreach my $jobID (@markedJobIDs){
	    writeToNewWindow($cgi->h3("Resuming Job $jobID") . "\n" . 
			     $cgi->pre(@{runLSFCmd("bresume $jobID 2>&1")}) .
			     "\n");
	}
    }elsif($action eq "Peek" && $expertMode){
	foreach my $jobID (@markedJobIDs){
	    writeToNewWindow($cgi->h3("Peeking at Job $jobID") . "\n" . 
			     $cgi->pre(@{runLSFCmd("bpeek $jobID 2>&1")}) .
			     "\n");
	}
    }

    return $text;
}

#
# use javascript to open a new window
# then write the given text there.
#

sub writeToNewWindow{
    my $text = shift;

    # fix double quotes and backslashes, should maybe do more to be safe 
    $text =~ s/\\/\\\\/g;
    $text =~ s/\"/\\\"/g;

    # eval is done so window has unique id, otherwise netscape keeps writing
    # to the same window
    print <<MICA;
<script language="JavaScript"><!--
var day = new Date();
var id = day.getTime();
eval("var myWindow = window.open('', '" + id + "', 'toolbars=0,scrollbars=1,location=0,statusbars=1,menubars=0,resizable=1');");  

MICA
#,width=600,height=200');");

    my @lines = split("\n",$text);
    foreach my $line (@lines){
	print "myWindow.document.write(\"$line\\n\");\n";
    }
    
    print "\n//--></script>\n";
    
}

#
# return the HTTP header and beginning html code
#

sub startDocument{
    my $cgi = shift;

    # start http & html
    my $text =  $cgi->header;
    $text .= $cgi->start_html(-title => "AutoQA LSF Utility") . "\n";

    # start the form
    $text .= $cgi->start_form(-action => $cgi->script_name() ) . "\n";

    # print the title
    $text .= $cgi->h1("LSF Monitor for RCAS") . "\n";
    return $text;
}

#
# return the ending html code
#

sub endDocument{
    my $cgi = shift;

    # end the form
    my $text = $cgi->end_form() . "\n";

    $text .= $cgi->end_html . "\n";
    
    return $text;
}

# 
# return a reference to a hash (by jobID) of hash references containing
# data on lsf jobs.  Each hash has keys 
# (jobID, user, status, queue, fromHost, execHost, jobName, submitTime)
#

sub bJobs{

    my $jobs = {};

    # get the jobs from bjobs
    my $lines = runLSFCmd("bjobs -w -u all");  # lists jobs for all users
    shift @$lines;                                 # discard header

    # extract fields from each line
    foreach my $line (@$lines){  
	my @fields = ($line =~ 
	 /^(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(.*\S+)\s+(.{12})/);
	my $job = {};

	foreach my $key (@$selectionKeys){
	    $job->{$key} = shift @fields; # keys have same order as fields
	}

	$jobs->{ $job->{jobID} } = $job;
    }
    
    return $jobs;
}

#
# given an array reference, removes duplicate elements.
# also returns the array reference
# 

sub removeDuplicates{

    my $arrayRef = shift;

    my %found = ();
    
    # loop through all elements, removing dupes
    for (my $i = 0; $i <= $#$arrayRef;$i++){
	if ($found{ $arrayRef->[$i] } eq 1){
	    splice(@$arrayRef, $i, 1); # not unique, cut it 
	    $i--;
	}else{
	    $found{ $arrayRef->[$i] } = 1;
	}
    }

    return $arrayRef;
}

#
# get allowed values for selection lists based on current jobs.
# If it doesn't appear in a current job, it won't be available.
# Include "any" job.
#

sub getFieldChoices{
    my $cgi = shift;
    my $jobs = shift;

    my $fieldChoices = {}; # ref to hash of array refs
    foreach my $key (@$selectionKeys){
	$fieldChoices->{$key} = [];
    }    

    # temporarily add "any" job to allow no selection on a field
    my $anyJob = {};
    foreach my $key (@$selectionKeys){
	$anyJob->{$key} = "any";
    }
    $jobs->{"any"} = $anyJob;

    # collect all possible field values, including duplicates
    foreach my $job (values %$jobs){
	foreach my $key (@$selectionKeys){
	    push @{ $fieldChoices->{$key} }, $job->{$key};
	}
    }
    delete $jobs->{"any"};
    
    # remove duplicate elements from each list of field values, then sort
    foreach my $key (@$selectionKeys){
	removeDuplicates($fieldChoices->{$key});
	$fieldChoices->{$key} = [sort(@{ $fieldChoices->{$key} })];
    }

    return $fieldChoices;
}

#
# returns whether or not any jobs were selected by form params
#

sub jobsSelected{
    my $cgi = shift;

    foreach my $key (@$selectionKeys){
	if ($cgi->param($key)){ return 1; }
    }

    return 0;
}

#
# runs an lsf command in a safe way, i.e. checks for the health of the 
# batch system.  returns "" if the any line of the command output contains
# "batch system daemon not responding".  Otherwise
# lsf commands will hang forever.  Returns a reference to the array of
# output lines if the batch system daemon is running ok.
#

sub runLSFCmd{
    my $cmd = shift;

    local *READER; 
    open(\*READER, "echo \$\$; ".$cmd." 2>&1 |" ); 

    my $result = [];

    # Is this the only way to get the command's pid?
    # I know it's not guaranteed, but it seems to work ok.
    my $lsfPID = <READER>; chomp $lsfPID; $lsfPID++;

    #print "reading output of '".$cmd."' w/pid $lsfPID<br>\n";
    while (<READER>)
    {
	#print "got '".$_."'<br>\n";
	if (/^batch system daemon not responding/){
	    print 
		"<font color=red><h1>Error: lsf daemon not responding.".
		    "</h1></font>\n";
	    kill 9, $lsfPID || die "could not kill $lsfPID";
	    close READER;
	    #print "killed $lsfPID and closed READER<br>\n";
	    return "";
	}else{
	    push @$result, $_;
	}
    }

    close READER;

    return $result;
}

sub reaper{
    #print "waiting for kid<br>\n";
    my $waitpid = wait;
    $SIG{CHLD} = 'reaper';
    #print "done waiting for kid $waitpid<br>\n";
}







