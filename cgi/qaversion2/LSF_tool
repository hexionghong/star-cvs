#!/usr/bin/perl

# LSF_tool provides a cgi interface to the lsf commands bjobs,
# bhist and bkill, bstop, bresume, peek.
#
# BEN(20jun2000)
#
# some semantics:  
#   "selected" jobs are those which are selected by 
#              attribute in the browser and returned to the user
#   "marked"   jobs are those which the user has chosen from among
#              the "selected" jobs using checkboxes
#
# To do:  perhaps encapsulate a "job" in an object with fields given by
# @$selectionKeys, and methods corresponding to the actions.

use strict;
use CGI;

#
# the keys and headings used in the various selection columns
#

my $selectionKeys = [
		     "jobID",
		     "user",
		     "status",
		     "queue",
		     "fromHost",
		     "execHost",
		     "jobName",
		     "submitTime"
		     ];
my $selectionLabels = [
		       "Job ID",
		       "User",
		       "Status",
		       "Queue",
		       "Submitted From",
		       "Executed On",
		       "Job Name",
		       "Submit Time"
		       ];

my $cgi = new CGI;

# don't buffer output
$| = 1;

# print out the beginning of the document
print startDocument($cgi);

# carry out any action requested by the user and print result to new window
print performAction($cgi);

print controlButtons($cgi);

# we need the lsf job information before printing the job table, but
# we don't want to call bjobs until after actions have been performed
my $jobs = bJobs();  # reference to hash (by jobID) of references to hashes

# print out the table which includes job selection controls and
# the selected jobs
print $cgi->table({-border=>1},
		  $cgi->Tr(
			   {-align=>"CENTER",-valign=>"TOP"},
			   selectionHeadings($cgi)
			   ) . "\n",
		  selectionControls($cgi, $jobs) . "\n",
		  selectedJobs($cgi, $jobs) . "\n"
		  ) . "\n";

print endDocument($cgi);

exit 0;

#
# return the control buttons for acting on the jobs
#

sub controlButtons{
    my $cgi = shift;

    my $text = "<br><b>View marked jobs:</b>\n";
    
    $text .= $cgi->submit(-name=>'action',
			  -value=>'Details') . "\n";
    $text .= $cgi->submit(-name=>'action',
			  -value=>'History') . "\n";
    $text .= $cgi->submit(-name=>'action',
			  -value=>'Peek') . "\n";

    $text .= "<br><b>Edit marked jobs:</b>\n";

    $text .= $cgi->submit(-name=>'action',
			  -value=>'Suspend') . "\n";
    $text .= $cgi->submit(-name=>'action',
			  -value=>'Resume') . "\n";
    $text .= $cgi->submit(-name=>'action',
			  -value=>'Kill') . "\n";

    $text .= "<br>\n";

    $text .= $cgi->submit(-value=>'Refresh Job List') . "\n";

    $text .= "<br>\n";

    return $text;
}

#
# return the title headings w/ sort buttons for the job table
#

sub selectionHeadings{
    my $cgi = shift;
    my $text = $cgi->td();

    # get a set of radio buttons to select the field to sort on
    my $radioButtons = [$cgi->radio_group(
					  -name=>'sortField',
					  -value=>$selectionKeys,
					  -default=>'jobID',
					  -nolabels=>1,
					  -onClick=>'this.form.submit()'
					  ) ];

    for(my $num = 0; $num <= $#$selectionKeys; $num++){
	$text .= $cgi->td(
			  {-bgcolor=>'yellow'},
			  $selectionLabels->[$num] .
			  "<br>\n(" . $radioButtons->[$num] . " sort)"
			  );
    }

    return $text;
}

#
# return the controls for selecting jobs by attribute
#

sub selectionControls{
    my $cgi = shift;
    my $jobs = shift;
    
    #
    # get allowed values for selection lists based on current jobs.
    # If it doesn't appear in a current job, it won't be available.
    #

    my $fieldChoices = {}; # ref to hash of array refs
    foreach my $key (@$selectionKeys){
	$fieldChoices->{$key} = [];
    }    

    # temporarily add "any" job to allow no selection on a field
    my $anyJob = {};
    foreach my $key (@$selectionKeys){
	$anyJob->{$key} = "any";
    }
    $jobs->{"any"} = $anyJob;

    # collect all possible field values, including duplicates
    foreach my $job (values %$jobs){
	foreach my $key (@$selectionKeys){
	    push @{ $fieldChoices->{$key} }, $job->{$key};
	}
    }
    delete $jobs->{"any"};
    
    # remove duplicate elements from each list of field values, then sort
    foreach my $key (@$selectionKeys){
	removeDuplicates($fieldChoices->{$key});
	$fieldChoices->{$key} = [sort(@{ $fieldChoices->{$key} })];
    }

    #
    # print the selection controls
    #

    # column selection controls
    my $text = "";
    $text .= $cgi->Tr(
		$cgi->td(
			 {-bgcolor=>'pink'},
			 "Mark Jobs"
			 ) . 
	        $cgi->td(
			 {-bgcolor=>'lightblue'},
			 [map({ 
			     $cgi->popup_menu( 
					       -name=>$_,
					       -values=>$fieldChoices->{$_},
					       -default=>"any",
					       -onchange=>"this.form.submit()"
					       )
			     } @$selectionKeys)
			  ])
		      ) . "\n";
    
    return $text;
}

#
# return the selected jobs, one per table row
#

sub selectedJobs{
    my $cgi = shift;
    my $jobs = shift;

    # get the jobs meeting the selection criteria
    my @selectedJobs = ();
    my @selectedJobIDs = ();
    
    if ($cgi->param("jobID")){ # selection params are valid (not first call)
      JOB_LOOP: foreach my $job (values %$jobs){
	  foreach my $key (@$selectionKeys){
	      if ($cgi->param($key) ne "" &&
		  $cgi->param($key) ne "any" &&
		  $cgi->param($key) ne $job->{$key}){
		  next JOB_LOOP;
	      }
	  }
	  # matches all necessary criteria, add it
	  push @selectedJobs, $job;
      }
    }else{                     # first call, show all jobs
	@selectedJobs = values %$jobs;
    }

    # sort the jobs based on the sortField parameter
    my $sortKey = $cgi->param('sortField');
    $sortKey or $sortKey = "jobID";   # first call, sort on job id
    @selectedJobs = sort {$a->{$sortKey} cmp $b->{$sortKey}} @selectedJobs;
    for (my $i = 0; $i <= $#selectedJobs; $i++){
	$selectedJobIDs[$i] = $selectedJobs[$i]->{"jobID"};
    }

    # get a set of checkboxes to select the rows (jobs)
    my @checkBoxes = $cgi->checkbox_group(
					  -name=>'markedJobs',
					  -value=>[@selectedJobIDs],
					  -nolabels=>1
					  );

    # generate the table text, one row per job
    my $text = "";
    for (my $i = 0; $i <= $#selectedJobs; $i++){
	$text .= $cgi->Tr(
			  $cgi->td(
				   {-bgcolor=>'pink'},
				    $checkBoxes[$i]
				   ) . 
			  $cgi->td([
				    map(
					{ $selectedJobs[$i]->{$_} } 
					@$selectionKeys)
				    ]) . "\n"
			  ) . "\n";
    }
    
    return $text;
}

#
# perform any action requested by the user and send the output to a new
# window
#

sub performAction{
    my $cgi = shift;

    my $action = $cgi->param("action");
    my @markedJobIDs = $cgi->param("markedJobs");

    my $text = "";
    if($action eq "Details"){
	foreach my $jobID (@markedJobIDs){
	    writeToNewWindow($cgi->h3("Details for Job $jobID") . "\n" .  
			     $cgi->pre(`bjobs -l $jobID 2>&1`) . "\n");
	}
    }elsif($action eq "History"){
	foreach my $jobID (@markedJobIDs){
	    writeToNewWindow($cgi->h3("History for Job $jobID") . "\n" . 
			     $cgi->pre(`bhist -l $jobID 2>&1`) . "\n");
	}
    }elsif($action eq "Kill"){
	foreach my $jobID (@markedJobIDs){
	    writeToNewWindow($cgi->h3("Killing Job $jobID") . "\n" . 
			     $cgi->pre(`bkill $jobID 2>&1`) . "\n");
	}
    }elsif($action eq "Suspend"){
	foreach my $jobID (@markedJobIDs){
	    writeToNewWindow($cgi->h3("Suspending Job $jobID") . "\n" .  
			     $cgi->pre(`bstop $jobID 2>&1`) . "\n");
	}
    }elsif($action eq "Resume"){
	foreach my $jobID (@markedJobIDs){
	    writeToNewWindow($cgi->h3("Resuming Job $jobID") . "\n" . 
			     $cgi->pre(`bresume $jobID 2>&1`) . "\n");
	}
    }elsif($action eq "Peek"){
	foreach my $jobID (@markedJobIDs){
	    writeToNewWindow($cgi->h3("Peeking at Job $jobID") . "\n" . 
			     $cgi->pre(`bpeek $jobID 2>&1`) . "\n");
	}
    }

    return $text;
}

#
# use javascript to open a new window
# then write the given text there.
#

sub writeToNewWindow{
    my $text = shift;

    # fix double quotes and backslashes, should maybe do more to be safe 
    $text =~ s/\\/\\\\/g;
    $text =~ s/\"/\\\"/g;

    # eval is done so window has unique id, otherwise netscape keeps writing
    # to the same window
    print <<MICA;
<script language="JavaScript"><!--
var day = new Date();
var id = day.getTime();
eval("var myWindow = window.open('', '" + id + "', 'toolbars=0,scrollbars=1,location=0,statusbars=1,menubars=0,resizable=1');");  

MICA
#,width=600,height=200');");

    my @lines = split("\n",$text);
    foreach my $line (@lines){
	print "myWindow.document.write(\"$line\\n\");\n";
    }
    
    print "\n//--></script>\n";
    
}

#
# return the HTTP header and beginning html code
#

sub startDocument{
    my $cgi = shift;

    # start http & html
    my $text =  $cgi->header;
    $text .= $cgi->start_html(-title => "AutoQA LSF Utility") . "\n";

    # start the form
    $text .= $cgi->start_form(-action => $cgi->script_name() ) . "\n";

    # print the title
    $text .= $cgi->h1("LSF Monitor for RCAS") . "\n";
    return $text;
}

#
# return the ending html code
#

sub endDocument{
    my $cgi = shift;

    # end the form
    my $text = $cgi->end_form() . "\n";

    $text .= $cgi->end_html . "\n";
    
    return $text;
}

# 
# return a reference to a hash (by jobID) of hash references containing
# data on lsf jobs.  Each hash has keys 
# (jobID, user, status, queue, fromHost, execHost, jobName, submitTime)
#

sub bJobs{

    my $jobs = {};

    # get the jobs from bjobs
    my @lines = `bjobs -w -u all`; # lists jobs for all users
    shift @lines;                          # discard header

    # extract fields from each line
    foreach my $line (@lines){  
	my @fields = ($line =~ 
	   /^(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(.*)\s+(.{12})/);
	my $job = {};

	foreach my $key (@$selectionKeys){
	    $job->{$key} = shift @fields; # keys have same order as fields
	}

	$jobs->{ $job->{jobID} } = $job;
    }
    
    return $jobs;
}

#
# given an array reference, removes duplicate elements.
# also returns the array reference
# 

sub removeDuplicates{

    my $arrayRef = shift;

    my %found = ();
    
    # loop through all elements, removing dupes
    for (my $i = 0; $i <= $#$arrayRef;$i++){
	if ($found{ $arrayRef->[$i] } eq 1){
	    splice(@$arrayRef, $i, 1); # not unique, cut it 
	    $i--;
	}else{
	    $found{ $arrayRef->[$i] } = 1;
	}
    }

    return $arrayRef;
}


