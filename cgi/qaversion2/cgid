#!/usr/bin/perl -I/star/u2e/bnorman/lib -w 

# QA cgi server   (cgid)
#
# BEN 2Apr00
#
# The sole purpose of cgid is to run allowed scripts and return the output,
# just like a cgi-only web server.  If given a request for a document other
# than those allowed, it gives a HTTP 404 error message.  
#
# 6jul00: cgid now recognizes paths in the url, see $script_dirs var
# 9jul00: cgid will now retrieve html docs from any directory under
#         those in $doc_dirs. directory listing is not allowed
# 21jul00: if you add a new directory to $script_dirs or $doc_dirs,
#          you must add that name to the url replacement string in
#          nph-http_forward.
#
# cgid makes the script think that it has been run as a normal cgi process.
# This is accomplished by parsing the HTTP request (from a normal web browser)
# and setting the CGI environment accordingly before calling the script.
#
# cgid forks a child to handle every new request.
#
# It stores its process id in /afs/rhic/star/starqa/var/run/cgid.pid.
# Logging is appended to /afs/rhic/star/starqa/var/log/cgid.log.
#
# Usage:  cgid [-p port] [-r] [-k] [-h] [-v]
#
# 'port' is the listening port (default 8080)
# -k kills cgid gently
# -r restarts cgid
# -h prints usage instructions
# -v prints log info to stderr
#
# cgid is suid starlib.  It needs an afs token to run.
# In practice, you will probably want to run this in the background,
# and it should definitely be run from the directory in which it lives.
#
#      cgid [options] &
#
# NOTE: cgid is biased to run on rcas by the path environment variable provided
#       to the child script
#

use HTTP::Daemon;
use Net::hostent; # OO getpeerbyaddr
use IPC::Open2;
use Getopt::Std;
use strict;
use Cwd;

$| = 1; # don't buffer output

my $my_name = "cgid";
my $script_names = ["QA_main.pm", "LSF_tool"];
my $var_dir = "/afs/rhic/star/starqa/var";
my $log_dir = "$var_dir/log";
my $run_dir = "$var_dir/run";
my $pid_file = "$run_dir/$my_name.pid";
my $log_file = "$log_dir/$my_name.log";

# look-up table for paths (aliases)
my $script_dirs = {
    "/ben"   => 
	"/star/u2e/bnorman/cgi-bin/qa",
    "/peter" => 
	"/afs/rhic/star/users/jacobs/QA/cgi/qaversion2",
    "/bum"   => 
	"/star/u2e/bum/cgi-bin/version2",
    "/v2"    => 
	"/afs/rhic/star/packages/dev/cgi/qaversion2",
    "/pro"   => 
	"/star/u2e/starqa/cgi-bin/pro/cgi/qaversion2"
    };

my $doc_dirs = $script_dirs;  # may change in the future

my %opt = ();
getopt('p', \%opt);

my $port = ($opt{p} ? $opt{p} : 8080);
my $daemon;
my $client;
my $request;
my $content;
my $url;

#
# handle shutdown or restart requests
#

processArgs();

#
# start logging and write out pid to give us an easy handle
#

system("echo $$ | cat > $pid_file");
printToLog ("$0.$$ starting\n");

#
# ignore all signals but SIGINT (^c) and SIGTSTP (^z)
#

setSignals();

#
# instantiate the http daemon
#

$daemon = new HTTP::Daemon( LocalPort => $port ) 
    or (printToLog ("$0.$$ can't open port $port") && cleanup() );
printToLog ("$0.$$ running CGI server on port $port");

#
# Loop through incoming HTTP requests
#

ACCEPT_LOOP: while ($client = $daemon->accept)
{
    #
    # read the HTTP request so we have some information about the connection
    #

    $client->autoflush(1); # don't buffer IO
    $request = $client->get_request;
    unless ($request)
    {
	$client = undef; # close connection
	printToLog ("$0.$$ got bad http request");
	next ACCEPT_LOOP
    }

    #
    # Log something to indicate we got the connection - it would be nice
    # to log the incoming ip, but this is always just the ssh gateway.
    # So we hope that there's some "user" identification in the http header.
    #
    
    printToLog ("$0.$$ got request from user " . 
		( defined $request->from() ? $request->from() : "UNKNOWN" )
		);
	
    # 
    # Fork off a child to handle this request so the parent can
    # continue accepting connections.
    #
    
    last ACCEPT_LOOP unless ( fork() );

    #
    # I'm the parent, let go of my copy of this connection &
    # wait for another
    #
    
    $client = undef;
}

#
# I'm the child, handle the request
#

printToLog ("$0.$$ child handling request '" . $request->url() . "'");

#
# process requests to allowed scripts, and docs in allowed dirs.
#

my ($script_name, $doc_name, $working_dir) = translateURL($request);

if ($script_name){       #this is an allowed cgi script

    #$client->send_basic_header;
    # for some reason, the above does not work ???

    #
    # set up the environment ala the CGI/1.1 "specification"
    #    - see http://Web.Golux.Com/coar/cgi/
    #
    
    printToLog("creating cgi environment variables");

    # start clean
    my $PATH = $ENV{PATH};
    %ENV = (); 
    $ENV{PATH} = $PATH;

    $url = $request->url();
    
    # query string (trailing "?<query string>")
    $ENV{QUERY_STRING} = $url->equery();
    # path info (trailing "</path info>" after script name
    $ENV{PATH_INFO} = $url->epath();
    $ENV{PATH_INFO} =~ s/^.*$script_name(.*)$/$1/;
    # path info intrpreted as a local directory
    $ENV{PATH_TRANSLATED} = ""; # QA_main.pm doesn't need this
    # script path
    $ENV{SCRIPT_NAME} = $url->epath();
    $ENV{SCRIPT_NAME} =~ s/^(.*$script_name).*$/$1/;

    # everything else
    $ENV{AUTH_TYPE} = ""; # QA_main.pm doesn't need this
    $ENV{CONTENT_LENGTH} = $request->content_length();
    if ($ENV{CONTENT_LENGTH} eq "")
    {
	$ENV{CONTENT_LENGTH} = 0;
    }
    $ENV{CONTENT_TYPE} = $request->content_type();
    $ENV{GATEWAY_INTERFACE} = "CGI/1.1";
    $ENV{REMOTE_ADDR} = $client->peerhost();
    $ENV{REMOTE_HOST} = gethostbyaddr( $client->peeraddr() )->name;
    $ENV{REMOTE_IDENT} = ""; # QA_main.pm doesn't need this
    $ENV{REMOTE_USER} = $request->from();
    $ENV{REQUEST_METHOD} = $request->method();
    $ENV{SERVER_NAME} = gethostbyaddr( $client->sockaddr() )->name;
    $ENV{SERVER_PORT} = $client->sockport();
    $ENV{SERVER_PROTOCOL} = "HTTP/1.1";
    $ENV{SERVER_SOFTWARE} = $my_name;

    #
    # send ouput of QA_main.pm, putting any POST content on stdin
    #

    STDERR->autoflush(1);
    
    local *Writer;
    local *Reader; 
    chdir $working_dir or die "cannot cd to $working_dir\n";

    printToLog("returning output");

    # BEN: put timeout on script 
    my @output = ();
    my $scriptPid = 0;
    # eval is necessary when using alarm because of system call in open2
    eval{
	local $SIG{ALRM} = sub{
	    print $client "HTTP/1.1 500 ERROR\n";
	    print $client "Content-type: text/html\n\n";
	    print $client "<h1>$script_name timed out.</h1>\n";
	    printToLog("$script_name timed out");

	    close Writer; close Reader; $client = undef;
	    
	    # destroy running script
	    kill 9, $scriptPid;
	    printToLog("killed $script_name (pid $scriptPid)");

	    exit(0);
	};
	
	alarm 30;

	printToLog("running script");
	$scriptPid = open2(\*Reader, \*Writer, "./$script_name"); 
	print Writer $request->content();
	@output = <Reader>;

	alarm 0;
    };
    if ($@){
	print $client "HTTP/1.1 500 ERROR\n";
	print $client "Content-type: text/html\n\n";
	print $client "<h1>$script_name died with error $!.</h1>\n";
	printToLog("$script_name died with error $!.\n");

	close Writer; close Reader; $client = undef;

	exit(0);
    }

    print $client "HTTP/1.1 200 OK\n";
    print $client join("", @output);

    #
    # clean up the mess
    #
    
    close Writer; close Reader; $client = undef;

    printToLog ("$0.$$ handled request for script'" . $request->url . 
		"', exiting");

}elsif($doc_name){

    #
    # send http headers and document
    #

#    print $client "HTTP/1.1 200 OK\n\n";
    $client->send_file_response("$working_dir/$doc_name");

    $client = undef;

    printToLog ("$0.$$ handled request for document'" . $request->url . 
		"', exiting");

}else{
    print $client "HTTP/1.1 404 File not found\n\n";
    print $client "<h1>'" . $request->url . "' not found</h1>\n";
    $client = undef; # close the connection

    printToLog ("$0.$$ ignored request for '" . $request->url . "', exiting");

}

exit 0;

#########################################################################

#
# handle ^c by shutting down the socket gracefully
#

sub cleanup
{
    printToLog ("$0.$$ exiting");

    if (defined $client) {$client = undef;} # close any http connection
    if (defined $daemon) {$daemon = undef;} # close socket
    if (-e $pid_file) {unlink $pid_file;}   # remove runtime pid file

    exit;
} # sub cleanup

sub print_usage
{
        print <<MICA;
 Usage:  $my_name [-p port] [-r] [-k] [-h] [-v]

 'port' is the listening port (default 8080)
 -k kills $my_name gently
 -r restarts $my_name
 -h prints usage instructions
 -v prints log info to stderr
MICA
}

# gets the name of the allowed script embedded in the request, or nothing
# if none is found.  also returns the filesystem directory of the script.
# if the url does not match an allowed script but matches an existing file
# residing in an allowed directory, return the name and directory of that
# document

sub translateURL {

    my $request = shift;

    # first check for allowed scripts
    foreach my $dir (keys %$script_dirs){
	my $working_dir = $script_dirs->{$dir};

	foreach my $script_name (@$script_names){
	    if ($request->url->path =~ m{^$dir/$script_name\b}){
		return $script_name, undef, $working_dir;
	    }
	}
    }

    
    # now for existing files
    foreach my $dir (keys %$doc_dirs){
	my $working_dir = $script_dirs->{$dir};

	$request->url->path =~ m{^$dir(.*)/([^/]*)$};
	$working_dir = "$working_dir$1";

	if ($2 && -e "$working_dir/$2"){
	    return undef, $2, $working_dir;
	}
    }

    return;
}


# print timestamped diagnostic message to someplace useful
# 
sub printToLog{
    my $msg = "[" . localtime() . "] " . shift();

    system("echo \"$msg\" >> $log_file.$$");
    $opt{v} && print STDERR "$msg\n";

}


#
# process command line args, handle shutdown or restart requests
#
sub processArgs{

    if ($opt{h})
    {
	print_usage();
	exit;
    }

    if ($opt{k} || $opt{r}){
	# get PID of running process
	my $kill_pid = `cat $pid_file`;
	if ($kill_pid){
	    print "Killing $my_name with pid $kill_pid...";
	    system "kill -INT $kill_pid";
	    print "done\n";
	}else{
	    print "No pid file found for $my_name.\n";
	}
    }
    
    if ($opt{k}){
	exit 0;
    }elsif ($opt{r}){
	print "Running new invocation of $my_name with pid $$.\n";
    }

}

#
# ignore all signals but SIGINT (^c), SIGCHLD, and SIGTSTP (^z)
#
sub setSignals{
    foreach my $key (keys(%SIG)){
	if ($key eq "INT"){
	    $SIG{$key} = 'cleanup';
	}elsif ($key eq "TSTP"){
	    $SIG{$key} = 'DEFAULT';
	}elsif ($key eq "CHLD"){
	    $SIG{$key} = 'reaper';
	}else{
	    $SIG{$key} = 'IGNORE';
	}
    }
}

sub reaper{
    my $waitpid = wait;
    $SIG{CHLD} = 'reaper';
}





























