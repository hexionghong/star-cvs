#!/afs/rhic/local/bin/perl
#
#  ctoohtml : a c/C++ to HTML filter
#
#     Copyright (C) 1995 Andrew H. Fagg (af0a@robotics.usc.edu)
#     
#     This program is free software; you can redistribute it and/or
#     modify it under the terms of the GNU General Public License
#     as published by the Free Software Foundation; either version 2
#     of the License, or any later version.
#     
#     This program is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
#     
#     You should have received a copy of the GNU General Public License
#     along with this program; if not, write to the Free Software
#     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
#
#
#  Usage: ctoohtml [-<parm>[<value>]]* <sourcefile>+
#   
#  For more information, see
#    http://www.usc.edu/dept/robotics/personal/af0a/tools/ctoohtml/ctoohtml.html
#
# HISTORY
# 
#  Andrew H. Fagg    12/20/95    Official release of Version 1.2
#                                   (now called ctoohtml)
#                                  - -C option indicates .c and .h files
#                                     are to be interpreted as C++ files.
#
#  Andrew H. Fagg    08/07/95    Version 1.1
#                                  - Added the ability for users to include
#                                   a description of their source files
#                                   that is automatically pulled out and
#                                   used in the source file index.
#
#  Andrew H. Fagg    07/31/95    Version 1.0
#                                  - Fixed bubble sort so that "tag class"
#                                   information is swapped correctly.
#                                  - Fixed bug that occurs when more than
#                                   one overload is detected for any one
#                                   tag.
#
#  Andrew H. Fagg    07/20/95    Version 0.2, Many changes:
#                                  - HTML markup may be in the code.
#                                  - Handles overloading of functions
#                                  - Added #define macro
#                                  - Added enum tag types
#                                  - Added NSL support
#                                  - Generates several indices:
#                                     1. files.html (list of all sources)
#                                     2. tags.all.html (list of tags)
#                                     3. tags.files.html (list sorted by file)
#                                  - Now can handle files outside of local dir
#                                  - Now user can specify dest dir for HTML 
#                                     files
#                                  - Fixed several bugs
#
#  Andrew H. Fagg    07/18/95    Original
#  
#
#
#

%parms = ();			# Parameters
				# Default parms
$parms{"t"} = "Source File Index"; # Title/Header for the index file.
$parms{"a"} = "All Tags Found in Source Files"; # Title/Header for the index file.
$parms{"f"} = "Tags Sorted by Source File"; # Title/Header for the index file.
$parms{"d"} = 0;		# Debug mask
$parms{"h"} = "Project Description";
$parms{"z"} = "./";

#
#  sub interpret_parms
#
#  Interpret the parameters and stuff them into the %parms
# structure.
#


sub interpret_parms
{
    local($i);

    foreach $i (@ARGV)		# Loop through each parm
    {
	if($i =~ /-(\w)(.*)/)	# Expect a -<N><val> where <N> is a single 
	{			#  letter.
	    $parms{$1} = $2;
	}
	else			# Not the right format.
	{
	    print "Parameter Error: \"$i\"\n";
	    exit;
	};
    };
};

#
#  sub parse_tag
#
#  Parse the tag file that is generated by etags and set up the necessary
# data structures to make the search process efficient...
#

sub parse_tag
{
    local($file, $path) = ("", "");

    unless(open(FP, "<TAGS"))
    {
	print "Error opening file TAGS.\n";
	exit;
    };

    %tag_info = ();

    $tag_info{"num"} = 0;	# Total number of tags that have been found.

    while($_ = <FP>)
    {
	if(/\014/)		# ^L indicates start of file
	{
	    $_ = <FP>;
	    if(/(.*),/)		# Parse out file name.
	    {
		$file =	$1;
				# If it includes a path, then split it out.
		if($file =~ /(.*\/)(.+)$/)
		{
		    $file = $2;
		    $path = $1;
		};
		if($parms{"d"} & 0x4)
		{
		    print "NEW FILE: " . $file . "\n";
		}
				# Counter indicates # of tags found in the
				#  file.
		$tag_info{"num", $file} = 0;

				# Add to the file list.
		if(defined $tag_info{"files"})
		{
		    $tag_info{"files"} = $tag_info{"files"} . "#" . $file;
		    $tag_info{"pathfiles"} = $tag_info{"pathfiles"} .
			"#" . $path . $file;
		}
		else		# First one in the list.
		{
		    $tag_info{"files"} = $file;
		    $tag_info{"pathfiles"} = $path . $file;
		};
	    }
	    else
	    {
		print "Error parsing file name.\n";
		exit;
	    };
	}
				# Define directive (macro)

	elsif(/\#\s*define\s+(\w+)\s*\(\177(\d+),(\d+)/)
	{
	    if($parms{"d"} & 0x4)
	    {
		print "DEFINE MACRO:$1** $2 ** $3\n";
	    }
				# Store in tag list for this file.
	    $tag_info{"tag type", $file, $tag_info{"num", $file}} = "MACRO";
	    $tag_info{"tag name", $file, $tag_info{"num", $file}} = $1;
	    $tag_info{"tag line", $file, $tag_info{"num", $file}} = $2;
	    $tag_info{"tag char", $file, $tag_info{"num", $file}} = $3;
	    $tag_info{"tag search", $file, $tag_info{"num", $file}} = "\\b" .
		&quote_string($tag_info{"tag name", $file, $tag_info{"num", $file}}) . "\\s*\\(";

				# Global list of tags.
	    $tag_info{"tag name", $tag_info{"num"}} =
		$tag_info{"tag name", $file, $tag_info{"num", $file}};
	    $tag_info{"tag order", $tag_info{"num"}} =
		&quote_string($tag_info{"tag name", $tag_info{"num"}});
	    $tag_info{"tag type", $tag_info{"num"}} =
		$tag_info{"tag type", $file, $tag_info{"num", $file}};

	    $tag_info{"tag search", $tag_info{"num"}} =
		$tag_info{"tag search", $file, $tag_info{"num", $file}};

	    $tag_info{"tag file", $tag_info{"num"}} = $file;

	    $tag_info{"num", $file}++;
	    $tag_info{"num"}++;
	}

				# Define directive

	elsif(/\#\s*define\s+(\w+)\s*\177(\d+),(\d+)/)
	{
	    if($parms{"d"} & 0x4)
	    {
		print "DEFINE:$1** $2 ** $3\n";
	    }
				# Store in tag list for this file.
	    $tag_info{"tag type", $file, $tag_info{"num", $file}} = "DEFINE";
	    $tag_info{"tag name", $file, $tag_info{"num", $file}} = $1;
	    $tag_info{"tag line", $file, $tag_info{"num", $file}} = $2;
	    $tag_info{"tag char", $file, $tag_info{"num", $file}} = $3;
	    $tag_info{"tag search", $file, $tag_info{"num", $file}} = "\\b" .
		&quote_string($tag_info{"tag name", $file, $tag_info{"num", $file}}) . "\\b";

				# Global list of tags.
	    $tag_info{"tag name", $tag_info{"num"}} =
		$tag_info{"tag name", $file, $tag_info{"num", $file}};
	    $tag_info{"tag order", $tag_info{"num"}} =
		&quote_string($tag_info{"tag name", $tag_info{"num"}});
	    $tag_info{"tag type", $tag_info{"num"}} =
		$tag_info{"tag type", $file, $tag_info{"num", $file}};

	    $tag_info{"tag search", $tag_info{"num"}} = 
		$tag_info{"tag search", $file, $tag_info{"num", $file}};

	    $tag_info{"tag file", $tag_info{"num"}} = $file;

	    $tag_info{"num", $file}++;
	    $tag_info{"num"}++;
	}

				# Class definition
	elsif(/class (~?)(\w+)\177(.+)\001(\d+),(\d+)/)
	{
	    if($parms{"d"} & 0x4)
	    {
		print "CLASS: $1 ** $2 ** $3 ** $4 ** $5\n";
	    }
				# Store in tag list for this file.
	    $tag_info{"tag type", $file, $tag_info{"num", $file}} = "CLASS";
	    $tag_info{"tag name", $file, $tag_info{"num", $file}} = $1 . $2;
	    $tag_info{"tag line", $file, $tag_info{"num", $file}} = $4;
	    $tag_info{"tag char", $file, $tag_info{"num", $file}} = $5;
	    $tag_info{"tag search", $file, $tag_info{"num", $file}} = "";

	    if($1 eq "")	# If it doesn't have a '~', then add the
	    {			#  word boundary constraint.  The ~ is an
				#  exception for class destructors.
		$tag_info{"tag search", $file, $tag_info{"num", $file}} .=
		    "\\b";
	    };
	    $tag_info{"tag search", $file, $tag_info{"num", $file}} .=
		&quote_string($tag_info{"tag name", $file, $tag_info{"num", $file}})  . "\\b";

				# Global list of tags.
	    $tag_info{"tag name", $tag_info{"num"}} =
		$tag_info{"tag name", $file, $tag_info{"num", $file}};
	    $tag_info{"tag order", $tag_info{"num"}} =
		&quote_string($tag_info{"tag name", $tag_info{"num"}});
	    $tag_info{"tag type", $tag_info{"num"}} =
		$tag_info{"tag type", $file, $tag_info{"num", $file}};

	    $tag_info{"tag search", $tag_info{"num"}} = 
		$tag_info{"tag search", $file, $tag_info{"num", $file}};


	    $tag_info{"tag file", $tag_info{"num"}} = $file;

	    $tag_info{"num", $file}++;
	    $tag_info{"num"}++;
	}
				# enum definition
	elsif(/enum\s+(\w+)\s*\177(.+)\001(\d+),(\d+)/)
	{
	    if($parms{"d"} & 0x4)
	    {
		print "ENUM: $1 ** $2 ** $3 ** $4\n";
	    }
				# Store in tag list for this file.
	    $tag_info{"tag type", $file, $tag_info{"num", $file}} = "CLASS";
	    $tag_info{"tag name", $file, $tag_info{"num", $file}} = $1;
	    $tag_info{"tag line", $file, $tag_info{"num", $file}} = $3;
	    $tag_info{"tag char", $file, $tag_info{"num", $file}} = $4;
	    $tag_info{"tag search", $file, $tag_info{"num", $file}} = "\\b" .
		&quote_string($tag_info{"tag name", $file, $tag_info{"num", $file}})  . "\\b";

				# Global list of tags.
	    $tag_info{"tag name", $tag_info{"num"}} =
		$tag_info{"tag name", $file, $tag_info{"num", $file}};
	    $tag_info{"tag order", $tag_info{"num"}} =
		&quote_string($tag_info{"tag name", $tag_info{"num"}});
	    $tag_info{"tag type", $tag_info{"num"}} =
		$tag_info{"tag type", $file, $tag_info{"num", $file}};

	    $tag_info{"tag search", $tag_info{"num"}} = 
		$tag_info{"tag search", $file, $tag_info{"num", $file}};

	    $tag_info{"tag file", $tag_info{"num"}} = $file;

	    $tag_info{"num", $file}++;
	    $tag_info{"num"}++;
	}

				# Struct definition

	elsif(/struct\s+(\w+)\177(.+)\001(\d+),(\d+)/)
	{
	    if($parms{"d"} & 0x4)
	    {
		print "STRUCT: $1 ** $2 ** $3 ** $4\n";
	    }
				# Store in tag list for this file.
	    $tag_info{"tag type", $file, $tag_info{"num", $file}} = "STRUCT";
	    $tag_info{"tag name", $file, $tag_info{"num", $file}} = $1;
	    $tag_info{"tag line", $file, $tag_info{"num", $file}} = $3;
	    $tag_info{"tag char", $file, $tag_info{"num", $file}} = $4;
	    $tag_info{"tag search", $file, $tag_info{"num", $file}} = "struct\\s+\\b" .
		&quote_string($tag_info{"tag name", $file, $tag_info{"num", $file}}) . "\\b";

				# Global list of tags.
	    $tag_info{"tag name", $tag_info{"num"}} =
		$tag_info{"tag name", $file, $tag_info{"num", $file}};
	    $tag_info{"tag order", $tag_info{"num"}} =
		&quote_string($tag_info{"tag name", $tag_info{"num"}});
	    $tag_info{"tag type", $tag_info{"num"}} =
		$tag_info{"tag type", $file, $tag_info{"num", $file}};

	    $tag_info{"tag search", $tag_info{"num"}} = 
		$tag_info{"tag search", $file, $tag_info{"num", $file}};

	    $tag_info{"tag file", $tag_info{"num"}} = $file;

	    $tag_info{"num", $file}++;
	    $tag_info{"num"}++;
	}
				# Function definition (for a class)
	elsif(/(\w+)::(~?\w+)\s*\(\177(\d+),(\d+)/)
	{
	    if($parms{"d"} & 0x4)
	    {
		print "CLASS FUNC: $1 ** $2 ** $3 ** $4\n";
	    };
				# Store in tag list for this file.
	    $tag_info{"tag type", $file, $tag_info{"num", $file}} = "FUNC";
	    $tag_info{"tag class", $file, $tag_info{"num", $file}} = $1;
	    $tag_info{"tag name", $file, $tag_info{"num", $file}} = $2;
	    $tag_info{"tag line", $file, $tag_info{"num", $file}} = $3;
	    $tag_info{"tag char", $file, $tag_info{"num", $file}} = $4;
	    $tag_info{"tag search", $file, $tag_info{"num", $file}} = 
		&quote_string($tag_info{"tag name", $file, $tag_info{"num", $file}})
		    . "\\s*\\(";

				# Global list of tags.
	    $tag_info{"tag name", $tag_info{"num"}} =
		$tag_info{"tag name", $file, $tag_info{"num", $file}};
	    $tag_info{"tag class", $tag_info{"num"}} = 
		$tag_info{"tag class", $file, $tag_info{"num", $file}};	# 
	    $tag_info{"tag order", $tag_info{"num"}} =
		&quote_string($tag_info{"tag name", $tag_info{"num"}});
	    $tag_info{"tag type", $tag_info{"num"}} =
		$tag_info{"tag type", $file, $tag_info{"num", $file}};

	    $tag_info{"tag search", $tag_info{"num"}} = 
		$tag_info{"tag search", $file, $tag_info{"num", $file}};

	    $tag_info{"tag file", $tag_info{"num"}} = $file;

	    $tag_info{"num", $file}++;
	    $tag_info{"num"}++;
	}

				# Normal function definition
	elsif(/(\w+)\s*\(\177(\d+),(\d+)/)
	{
	    if($parms{"d"} & 0x4)
	    {
		print "FUNC: $1 ** $2 ** $3\n";
	    };
				# Store in tag list for this file.
	    $tag_info{"tag type", $file, $tag_info{"num", $file}} = "FUNC";
#	    $tag_info{"tag class", $file, $tag_info{"num", $file}} = "";
	    $tag_info{"tag name", $file, $tag_info{"num", $file}} = $1;
	    $tag_info{"tag line", $file, $tag_info{"num", $file}} = $2;
	    $tag_info{"tag char", $file, $tag_info{"num", $file}} = $3;
	    $tag_info{"tag search", $file, $tag_info{"num", $file}} = "\\b" .
		&quote_string($tag_info{"tag name", $file, $tag_info{"num", $file}})
		    . "\\s*\\(";


				# Global list of tags.
	    $tag_info{"tag name", $tag_info{"num"}} =
		$tag_info{"tag name", $file, $tag_info{"num", $file}};
	    $tag_info{"tag order", $tag_info{"num"}} =
		&quote_string($tag_info{"tag name", $tag_info{"num"}});
	    $tag_info{"tag type", $tag_info{"num"}} =
		$tag_info{"tag type", $file, $tag_info{"num", $file}};

	    $tag_info{"tag search", $tag_info{"num"}} =
		$tag_info{"tag search", $file, $tag_info{"num", $file}};


	    $tag_info{"tag file", $tag_info{"num"}} = $file;

	    $tag_info{"num", $file}++;
	    $tag_info{"num"}++;
	}
				# Don't know... wing it... 
	elsif(/.*\177\s*\b(\w+)\b\s*\001(\d+),(\d+)/)
	{
	    if($parms{"d"} & 0x4)
	    {
		print "WINGING IT: $1 ** $2 ** $3\n";
	    }
	    print "Warning: unknown tag type found: \"$1\". File: $file, line $2 (may be ok)\n";

				# Store in tag list for this file.
	    $tag_info{"tag type", $file, $tag_info{"num", $file}} = "UNKNOWN";
	    $tag_info{"tag name", $file, $tag_info{"num", $file}} = $1;
	    $tag_info{"tag line", $file, $tag_info{"num", $file}} = $2;
	    $tag_info{"tag char", $file, $tag_info{"num", $file}} = $3;
	    $tag_info{"tag search", $file, $tag_info{"num", $file}} = "\\b" .
		&quote_string($tag_info{"tag name", $file, $tag_info{"num", $file}})  . "\\b";

				# Global list of tags.
	    $tag_info{"tag name", $tag_info{"num"}} =
		$tag_info{"tag name", $file, $tag_info{"num", $file}};
	    $tag_info{"tag order", $tag_info{"num"}} =
		&quote_string($tag_info{"tag name", $tag_info{"num"}});
	    $tag_info{"tag type", $tag_info{"num"}} =
		$tag_info{"tag type", $file, $tag_info{"num", $file}};

	    $tag_info{"tag search", $tag_info{"num"}} = 
		$tag_info{"tag search", $file, $tag_info{"num", $file}};

	    $tag_info{"tag file", $tag_info{"num"}} = $file;

	    $tag_info{"num", $file}++;
	    $tag_info{"num"}++;
	}



				# Don't know... wing it...  (even more general)
	elsif(/.*\b(\w+)\b\s*\177(\d+),(\d+)/)
	{
	    if($parms{"d"} & 0x4)
	    {
		print "WINGING IT (general): $1 ** $2 ** $3\n";
	    }
	    print "Warning: unknown tag type found: \"$1\". File: $file, line $2 (may be ok)\n";

				# Store in tag list for this file.
	    $tag_info{"tag type", $file, $tag_info{"num", $file}} = "UNKNOWN";
	    $tag_info{"tag name", $file, $tag_info{"num", $file}} = $1;
	    $tag_info{"tag line", $file, $tag_info{"num", $file}} = $2;
	    $tag_info{"tag char", $file, $tag_info{"num", $file}} = $3;
	    $tag_info{"tag search", $file, $tag_info{"num", $file}} = "\\b" .
		&quote_string($tag_info{"tag name", $file, $tag_info{"num", $file}})  . "\\b";

				# Global list of tags.
	    $tag_info{"tag name", $tag_info{"num"}} =
		$tag_info{"tag name", $file, $tag_info{"num", $file}};
	    $tag_info{"tag order", $tag_info{"num"}} =
		&quote_string($tag_info{"tag name", $tag_info{"num"}});
	    $tag_info{"tag type", $tag_info{"num"}} =
		$tag_info{"tag type", $file, $tag_info{"num", $file}};

	    $tag_info{"tag search", $tag_info{"num"}} = 
		$tag_info{"tag search", $file, $tag_info{"num", $file}};

	    $tag_info{"tag file", $tag_info{"num"}} = $file;

	    $tag_info{"num", $file}++;
	    $tag_info{"num"}++;
	}


				# Else barf
	else
	{
	    print "Can't parse line:\n";
	    print;
	    exit;
	}
    }
    return %tag_info;
};

#
#  sub sub_ptr
#
#   Take a line from the code (<$strg>) and insert hyperlinks from
# all tags that are found in the line to where the tags are defined.
# Inputs:
#   $strg = string to be searched
#   $fname = the current file name being operated on (to determine
#      if the hyperlink is a local jump or not)
#   $i = the tag index to start searching (high-level calls are made
#      with $i = 0).
# Return = ($mstrg, $exceptions)
#

sub sub_ptr
{
    local($strg, $fname, $i) = @_;
    local($exceptions) = "";
    local($left, $right, $eleft, $eright, $match);
    local($ref);

				# Basis case for recursion
    if($strg eq "" || $strg eq "\n")
    {
	return ($strg, "");
    };

    if($i == 0)			# Only check for variables on first iteration.
    {
				# See if we recognize a variable
	if($strg =~ /\[DEFINE\s+(\w+)\s*=\s*([^\]]+)\]/)
	{
	    if(defined $tag_info{"VAR", $fname, $1})
	    {
		print "Variable $1 defined more than once in $fname.  Ignoring...\n";
	    }
	    else
	    {
		print "Defined $1 as \"$2\" in $fname\n";
		$tag_info{"VAR", $fname, $1} = $2;
	    };
	};
    };

    for(; $i < $tag_info{"num"}; ++$i) # Loop through remaining tags in list
    {
				# not the first occurrence of an overloaded tag
	if(!defined $tag_info{"tag exception flag", $i}	
				# found in string
	   && $strg =~ /(.*)($tag_info{"tag search", $i})(.*)(\n?)$/) 
	{
	    $left = $1;
	    $match = $2;
	    $right = $3 . $4;

				# Compute hyperlink reference

	    if(defined $tag_info{"tag exception", $i})
	    {			# Overloaded tag
				# Just underline item matched and
				# flag exception

		$ref = "<U>" . $match . "</U>";

		$exceptions = $tag_info{"tag exception", $i};
	    }
	    else		# Not overloaded, build hyperlink
	    {
		
				# Local reference
		if($fname eq $tag_info{"tag file", $i})
		{
		    $ref = "<A HREF=\"#" . $tag_info{"tag name", $i} . "\">";
		}
		else		# Reference to another file.
		{
		    $ref = "<A HREF=\"". $tag_info{"tag file", $i}
		    . ".html#" . $tag_info{"tag name", $i} . "\">";
		};

				# Hyperlink terminator
		$ref .= $match . "\</A\>";
	    };



				# Recurse to the left
	    ($left,$eleft) = &sub_ptr($left, $fname, $i);

				# Recurse to the right
	    ($right, $eright) = &sub_ptr($right, $fname, $i);
	    
				# Combine results
	    $strg = $left . $ref . $right;

				# Combine exceptions
	    if($exceptions ne "" && $eleft ne "")
	    {
		$exceptions = $eleft . "; " . $exceptions;
	    }
	    else
	    {
		$exceptions .= $eleft;
	    };

	    if($exceptions ne "" && $eright ne "")
	    {
		$exceptions .= "; " . $eright;
	    }
	    else
	    {
		$exceptions .= $eright;
	    };
	    
	    return ($strg, $exceptions);
	};
    };
    return ($strg, $exceptions);
};

#
#  sub quote_string
#
#  Insert character quotes (ie \) in front of tag characters that might
# confuse the regular expression processing.
#  Currently, the only known difficulties (that will occur in C code) are:
#    ~
#


sub quote_string
{
    local($strg) = @_;

    $strg =~ s/\~/\\\~/g;
    return $strg;
};


#
#  sub process_file
#
#  Go through a single source file and augment it with markup.
#

sub process_file
{
    local($fname, $path, $dest) = @_;
    local($ofname) = $fname . ".html";
    local($line) = 1;
    local($last_index) = 0;
    local($strg, $exceptions);
    local($left, $match, $right, $eleft, $eright);
    local($nsl_flag);

    unless(open(FPI, "<$path$fname")) # Open input file
    {
	print "Can't find input file $fname\n";
    };

    unless(open(FPO, ">$dest/$ofname")) # Output HTML file
    {
	print "Can't open output file $ofname\n";
    };

    print FPO "<HTML>\n";	# HTML header
    print FPO "<PRE>\n";
				# If the user has defined a pointer to a 
				#  project description, then use it at
				#  the top.
    if(defined $parms{"p"})
    {
	print FPO "<H1><A HREF=\"" . $parms{"p"} . "\">" .
	    $parms{"h"} . "</A></H1>\n\n";
    }
				# File name
    print FPO "<H2>file: $path$fname</H2>\n\n\n";

    while($_ = <FPI>)		# Examine each line
    {
	s/\</&lt;/g;		# Replace < with HTML equiv
	s/\>/&gt;/g;		# Replace > with HTML equiv

	s/\[\&lt;/\</g;		# Switch back to < if HTML markup was intended
	s/\&gt;\]/\>/g;		#   (as denoted by [< and >] for < and >.

				# Does this line contain a tag?
				# (we know this by looking at the line number)
	if($last_index < $tag_info{"num", $fname}
	   && $line == $tag_info{"tag line", $fname, $last_index})
	{
				# Yes.  Find it and add an anchor.

				# Are we in NSL mode?
	    $nsl_flag = 0;
	    if(defined $parms{"n"} &&
	       ($tag_info{"tag name", $fname, $last_index} =~ /RUN_MODULE/ ||
		$tag_info{"tag name", $fname, $last_index} =~ /INIT_MODULE/))
	    {
				# Yes - look for a MODULE definition
		if(!($_ =~ /(.*RUN_MODULE\s*\(\s*)(\w+)(\s*\).*)(\n?)$/ ||
		     $_ =~ /(.*INIT_MODULE\s*\(\s*)(\w+)(\s*\).*)(\n?)$/))
		{
		    print "Error finding tag " .
			$tag_info{"tag search", $fname, $last_index}. "\n";
		    print $_;
		    exit;
		}
		$left = $1;
		$match = $2;
		$right = $3 . $4;

		$nsl_flag = 1;

		if($parms{"d"} & 0x2)
		{
		    print "FOUND NSL MODULE $match in file $fname\n";
		};

				# We have discovered another string that
				#  we would like to list as a tag (ie $match)
				#  Although we do not expect to have references
				#  to this tag in the code, we would like to
				#  have it show up in the indices that we
				#  generate later.  So - we insert the
				#  tag information at this time.
		$tag_info{"tag type", $fname, $tag_info{"num", $fname}} =
		    "FUNC";
		$tag_info{"tag name", $fname, $tag_info{"num", $fname}} =
		    $match;

		$tag_info{"tag type", $tag_info{"num"}} =
		    "FUNC";
		$tag_info{"tag name", $tag_info{"num"}} =
		    $match;
		$tag_info{"tag file", $tag_info{"num"}} =
		    $fname;

				# Flag as an exception so that &sub_ptr()
				#  doesn't try to match it.
		$tag_info{"tag exception flag", $tag_info{"num"}} = "";

		$tag_info{"num", $fname}++;
		$tag_info{"num"}++;

				# Flag this $last_index as a NSL module
		$tag_info{"tag NSL flag", $fname, $last_index} = "";
	    }
	    else		# No, just look for the specified tag
	    {
		if(!($_ =~ /(.*)($tag_info{"tag search", $fname, $last_index})(.*)(\n?)$/))
		{			# Can't find.

		    print "Error finding tag " .
			$tag_info{"tag search", $fname, $last_index}. "\n";
		    print $_;
		    exit;
		}
		$left = $1;
		$match = $2;
		$right = $3 . $4;
	    };
				# The resulting pieces look like this:

				# Check left and right sides to see if 
				#  hyperlinks need to be added.

	    ($left, $eleft) = &sub_ptr($left, $fname, 0);
	    ($right, $eright) = &sub_ptr($right, $fname, 0);



				# Write out line

	    print FPO "<B>";	# Bold entire line

				# Left string
	    print FPO $left;

				# Add an HTML anchor to C tag.

	    if($nsl_flag)	# We have found a NSL exception
	    {
		print FPO "<A NAME=\"" . $match . "\">" . $match . "</A>";
	    }
	    else		# Normal operation
	    {
		print FPO "<A NAME=\"" . $tag_info{"tag name", $fname, $last_index}
	        . "\">";
		print FPO $match;
		print FPO "</A>";
	    }
	    
	    chop $right;	# Right string
	    print FPO $right;
	    print FPO "</B>";

				# Handle exceptions
	    if($eleft ne "" && $eright ne "")
	    {
		$eleft .= "; " . $eright;
	    }
	    else
	    {
		$eleft .= $eright;
	    };

	    if($eleft ne "")
	    {
		print FPO "     //OVERLOAD CALL: " . $eleft;
	    };
	    print FPO "\n";

	    $last_index++;


	}

				# A tag is not contained in the line...

				# Is this an #include directive?
	elsif(/\#\s*include (")(.+)(")/ || /\#\s*include (\&lt;)(.+)(\&gt;)/)
	{
				# Was this a file that we know about?
	    if(defined $tag_info{"num", $2})
	    {
				# Yes - generate a link to it.

		print FPO "#include " . $1 . "<A HREF=\"" .
		    $2 . ".html\">" . $2 . "</A>" .$3 . "\n";
	    }

	    else		# No  - just write the line out.
	    {
		print FPO;
	    }
	}


	else			# Nothing special, just write the line.
	{
				# Add hyperlinks to line if a tag is
				#  referenced in the code.
	    ($strg, $exceptions) = &sub_ptr($_, $fname, 0);

				# Were there any exceptions?
	    if($exceptions ne "")
	    {
				# Yes, append them...
		chop $strg;
		print FPO $strg . "        //OVERLOAD CALL: " . $exceptions . "\n";
	    }
	    else		# No, just write out the results
	    {
		print FPO $strg;
	    };
	};
	$line++;
    }
				# Footer
    print FPO "<P>\n";
    print FPO "<P>\n<HR>\n";
    print FPO "<H2>Back to <A HREF=\"files.html\">" . $parms{"t"} . "</A></H2><P>\n";

				# If the user has defined a pointer to a 
				#  project description, then use it at
				#  the top.
    if(defined $parms{"p"})
    {
	print FPO "<H2>Back to <A HREF=\"" . $parms{"p"} . "\">" .
	    $parms{"h"} . "</A></H2>\n";
    }

    print FPO "<P><HR>\n";
    print FPO "<H5>C++ to HTML Conversion by <I><A HREF=\"http://www.usc.edu/dept/robotics/personal/af0a/tools/ctoohtml/ctoohtml.html\">ctoohtml</A></I></H5>\n";
    print FPO "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n";
    print FPO "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n";
    print FPO "</PRE>\n"; 
    print FPO "</HTML>\n";

    close FPI;
    close FPO;
};

#
#  sub order_tags
#
#  Bubble sort the tag list.  The criterion for the sort is that 
# the most specific tag (search strings) must occur first in the list
# so that they will be mached first when we are processing the lines in
# the file.
#

sub order_tags
{
    local($i, $j);
    local($name, $order, $type, $search, $display, $file, $class);

    for($i = 0; $i < $tag_info{"num"} - 1; ++$i)
    {
	for($j = $i+1; $j < $tag_info{"num"}; ++$j)
	{
				# If the earlier one is a substring of
				# the later and they are not identical
	    if(($tag_info{"tag order", $j} =~ /$tag_info{"tag order", $i}/)
	       && ($tag_info{"tag order", $i} ne $tag_info{"tag order", $j}))
	    {
#		print "*****\n";
#		print $tag_info{"tag search", $j} . " " .
#		    $tag_info{"tag search", $i}  . "\n";

				# Swap the two entries.
		$name = $tag_info{"tag name", $i};
		$order = $tag_info{"tag order", $i};
		$type = $tag_info{"tag type", $i};
		$search = $tag_info{"tag search", $i};
		$file = $tag_info{"tag file", $i};
		$class = $tag_info{"tag class", $i};

		$tag_info{"tag name", $i} = $tag_info{"tag name", $j};
		$tag_info{"tag order", $i} = $tag_info{"tag order", $j};
		$tag_info{"tag type", $i} = $tag_info{"tag type", $j};
		$tag_info{"tag search", $i} = $tag_info{"tag search", $j};
		$tag_info{"tag file", $i} = $tag_info{"tag file", $j};
		$tag_info{"tag class", $i} = $tag_info{"tag class", $j};

		$tag_info{"tag name", $j} = $name;
		$tag_info{"tag order", $j} = $order;
		$tag_info{"tag type", $j} = $type;
		$tag_info{"tag search", $j} = $search;
		$tag_info{"tag file", $j} = $file;
		$tag_info{"tag class", $j} = $class;

	    }
	}
    }
};

#  
#  sub check_duplicates
#
#  Check each pair of tags for duplicates.  If there are, then
# this indicates that a tag has been overloaded.  When we find a
# reference to the overloaded tag in the code, we don't know where
# to generate the hyperlink to (since there are several choices).
# This is handled here by just providing a list of possibilities at 
# the end of the line.
#  So, when this routine detects a duplicate:
#   1.  The 'list of possibilities' is assembled and associated with
#      the first occurrence of the tag.
#   2.  Other occurrences are flagged as not needing to be searched
#      by &sub_ptr()
#
#  An exception line has the form:
#    <func>: [<file name>(<class name>),]+
#  e.g.
#    "foo: foo.c(foo_class), bogus.c(bogus_class)"
#

sub check_duplicates
{
    local($i, $j);

				# Loop through each known tag
    for($i = 0; $i < $tag_info{"num"}-1; ++$i)
    {

				# If this is NSL, then deactivate
				#  this tag all together by marking it
				#  as a 2nd or later exception
	if(defined $parms{"n"} &&
	   ($tag_info{"tag name", $i} =~ /RUN_MODULE/ ||
	    $tag_info{"tag name", $i} =~ /INIT_MODULE/))
	{
	    $tag_info{"tag exception flag", $i} = "";
	    $tag_info{"tag NSL flag", $i} = "";
	    if($parms{"d"} & 0x2)
	    {
		print "NSL MODULE filtered out.\n";
	    };
	}


	else
        {			# This tag has not been identified already
				#  as a duplicate?
	if(!defined $tag_info{"tag exception flag", $i})
	{
				# Loop through remaining tags
	for($j=$i+1; $j < $tag_info{"num"}; ++$j)

	{			# Are they the same?
	    if($tag_info{"tag search", $i} eq $tag_info{"tag search", $j})
	    {
				# Duplicate detected.
		if(!defined $tag_info{"tag exception", $i})
		{		# First duplicate found for element $i
				# $i is therefore the first occurrence

				# Header
		    $tag_info{"tag exception", $i} =
			$tag_info{"tag name", $i} . ": " .

				# Reference to element $i
			    "<A HREF=\"" . $tag_info{"tag file", $i} .
				".html#" . $tag_info{"tag name", $i} . "\">" .
				    $tag_info{"tag file", $i} . "(";

				# Class known?
		    if(!defined $tag_info{"tag class", $i})
		    {		# No - just put a ?
			$tag_info{"tag exception", $i} .= "?";			
		    }
		    else	# Yes
		    {
			$tag_info{"tag exception", $i} .=
			    $tag_info{"tag class", $i};
		    }
				# End of exception info for $i
		    $tag_info{"tag exception", $i} .= ")</A>";
		}

				# Append reference to $j
				# $j is at least the 2nd occurrence of the tag

		$tag_info{"tag exception", $i} .= ", " .
		    "<A HREF=\"" . $tag_info{"tag file", $j} .
			".html#" . $tag_info{"tag name", $j} . "\">" .
			    $tag_info{"tag file", $j} . "(";

				# Does it have a class?
		if(!defined $tag_info{"tag class", $j})
		{		# No - just write a ?
		    $tag_info{"tag exception", $i} .= "?";			
		}
		else		# Yes
		{
		    $tag_info{"tag exception", $i} .=
			$tag_info{"tag class", $j};
		};
				# End of $j
		$tag_info{"tag exception", $i} .= ")</A>";

				# Flag $j as being a duplicate.
		$tag_info{"tag exception flag", $j} = "";

				# Report warning to the user.
		print "Warning: overloaded tag (" .
		    $tag_info{"tag name", $i} . ") found.\n";
		print $tag_info{"tag file", $i} . "(" .
		    $tag_info{"tag class", $i} . ") and ";
		
		print $tag_info{"tag file", $j} . "(" .
		    $tag_info{"tag class", $j} . ").\n";
		
	    }
	}
    }
    }
    }
				# Check the last tag for a NSL exception
    if(defined $parms{"n"} &&
        ($tag_info{"tag name", $tag_info{"num"}-1} =~ /RUN_MODULE/ ||
	$tag_info{"tag name", $tag_info{"num"}-1} =~ /INIT_MODULE/))
    {
	$tag_info{"tag exception flag", $tag_info{"num"}-1} = "";
	$tag_info{"tag NSL flag", $tag_info{"num"}-1} = "";
	if($parms{"d"} & 0x2)
	{
	    print "NSL MODULE filtered out.\n";
	};
    };
};

#
#  sub postprocess_tags
#
#  Now that the tags have been read in, do some manipulations before
# we go to process the files.
#


sub postprocess_tags
{
    local($i);

    &order_tags();		# Sort the global tag list
    &check_duplicates();	# Overload detection

    if($parms{"d"} & 0x1)
    {
	print "TAGS:\n";
	for($i = 0; $i < $tag_info{"num"}; ++$i)
	{
	    print $i .": " . $tag_info{"tag search", $i} . "\n";
	};
	print "***\n";
    };
};

#
#  sub process_files
#
#   Loop through all of the files & process each one.
#
   

sub process_files
{
    local(@files) = ();
    local($file, $path);

				# Create the destination directory if
				#  it doesn't already exist.
    if(!-e $parms{"z"})		#  Rely on umask to handle the permissions.
    {
	mkdir ($parms{"z"}, 0777) || die "mkdir : $!";
    };
				# Extract list of files
    @files = split(/\#/, $tag_info{"pathfiles"});

				# Process each one.
    foreach $file (@files)
    {
	if($file =~ /(.*\/)(.+)$/)
	{
	    $file = $2;
	    $path = $1;
	};
	print "***********************************\n";
	print $file . "\n";
	&process_file($file, $path, $parms{"z"});
    };
    
};

#
#  sub generate_index
#
#  Generate an HTML file that contains a list of all source files.
#

sub generate_index
{
    local($fname, $dest, $title) = @_;
    local(@files, $i, $len);

    unless(open(FP, ">$dest/$fname"))
    {
	print "Error opening file $fname\n";
	exit;
    }

    print FP "<HTML>\n";
    print FP "<TITLE>$title</TITLE>\n";
				# If the user has defined a pointer to a 
				#  project description, then use it at
				#  the top.
    if(defined $parms{"p"})
    {
	print FP "<H1><A HREF=\"" . $parms{"p"} . "\">" .
	    $parms{"h"} . "</A></H1>\n\n";
    }

    print FP "<H1>$title</H1>\n";
    print FP "<H2>Source Files</H2>\n";
    print FP "<PRE>\n<UL>\n";

				# Extract list of files
    @files = split(/\#/, $tag_info{"files"});
				# Process them in some reasonable order
    @files = sort(@files);
    foreach $i (@files)
    {				# Generate link for name
	print FP "<LI> <A HREF=\"$i.html\">$i</A> ";

				# If there was a description, then add it.
	if(defined($tag_info{"VAR", $i, "DESCRIPTION"}))
	{
	    $len = 20 - length($i); # Preceding spaces...
	    $len = ($len > 0) ? $len : 1;
	    print FP " " x $len;
	    print FP "(" . $tag_info{"VAR", $i, "DESCRIPTION"} . ")";
	}
	print FP "\n";
    };

    print FP "</UL>\n</PRE><P>\n";
				# Pointers to the tag index files.

    print FP "<H2>Tag Indices</H2>\n";
    print FP "<UL>\n";
    print FP "<LI> <A HREF=\"tags.all.html\">"
	. $parms{"a"} . "</A>\n";
    print FP "<LI> <A HREF=\"tags.file.html\">"
	. $parms{"f"} . "</A>\n";
    print FP "</UL>\n<P>\n";

				# Footer
    print FP "<P>\n<HR>\n";
    print FP "<H5>C++ to HTML Conversion by <I><A HREF=\"http://www.usc.edu/dept/robotics/personal/af0a/tools/ctoohtml/ctoohtml.html\">ctoohtml</A></I></H5>\n";
    print FP "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n";
    print FP "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n";

    print FP "</HTML>\n";
    

    close FP;
};


#
#  sub generate_all_tags
#
#  Generate an HTML file containing a sorted list of all
# tags, hyperlinked to the location at which they are defined.
#

sub generate_all_tags
{
    local($fname, $dest, $title) = @_;
    local($i, $tag, $strg);
    local(@tags) = ();
				# Open output file
    unless(open(FP, ">$dest/$fname"))	
    {
	print "Error opening file $fname\n";
	exit;
    }
				# Header
    print FP "<HTML>\n";
    print FP "<TITLE>$title</TITLE>\n";
				# If the user has defined a pointer to a 
				#  project description, then use it at
				#  the top.
    if(defined $parms{"p"})
    {
	print FP "<H1><A HREF=\"" . $parms{"p"} . "\">" .
	    $parms{"h"} . "</A></H1>\n\n";
    }
    print FP "<H1>$title</H1>\n";
    print FP "<H2>Tags</H2>\n";
    print FP "<UL>\n";
				# Collect a list of all the tags + file name
    for($i = 0; $i < $tag_info{"num"}; ++$i)
    {
				# Only include if not a NSL MODULE.
	if(!defined $tag_info{"tag NSL flag", $i})
	{
				# Tag name
	    $strg = $tag_info{"tag name", $i};

				# Indicate if it is a function call by adding()
	    if($tag_info{"tag type", $i} eq "FUNC"
	       || $tag_info{"tag type", $i} eq "MACRO")
	    {
		$strg .= "()";
	    };
				# File name
	    $strg .= "    (" . $tag_info{"tag file", $i} . ")";
	    push(@tags, $strg);
	};
    };

    @tags = sort(@tags);	# Order the tags.

				# Loop through the sorted tags and
				#  report each one.
    foreach $tag (@tags)
    {				# First matches functions, 2nd does not
	$tag =~ /(\~?\w*)\(\)\s*\((.*)\)/ || $tag =~ /(\w*)\s*\((.*)\)/;
	print FP "<LI> <A HREF=\"$2.html#$1\">$tag</A>\n";
    };

				# Terminate list
    print FP "</UL>\n<P>\n";
				# Pointers to the other files.

    print FP "<H2> <A HREF=\"tags.file.html\">"
	. $parms{"f"} . "</A></H2>\n";
    print FP "<H2>Back to <A HREF=\"files.html\">" . $parms{"t"} . "</A></H2><P>\n";

				# Footer
    print FP "<P>\n<HR>\n";
    print FP "<H5>C++ to HTML Conversion by <I><A HREF=\"http://www.usc.edu/dept/robotics/personal/af0a/tools/ctoohtml/ctoohtml.html\">ctoohtml</A></I></H5><P>\n";
    print FP "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n";
    print FP "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n";

    print FP "</HTML>\n";
    

    close FP;
};


#
#  sub generate_file_tags
#
#    Generate an HTML file that lists all of the tags, sorted by 
# the file in which they are defined.
#

sub generate_file_tags
{
    local($fname, $dest, $title) = @_;
    local($i, $tag, $strg);
    local(@tags) = ();
    local(@files, $file);

    
				# Open output file
    unless(open(FP, ">$dest/$fname"))	
    {
	print "Error opening file $fname\n";
	exit;
    }
				# Header
    print FP "<HTML>\n";
    print FP "<TITLE>$title</TITLE>\n";
				# If the user has defined a pointer to a 
				#  project description, then use it at
				#  the top.
    if(defined $parms{"p"})
    {
	print FP "<H1><A HREF=\"" . $parms{"p"} . "\">" .
	    $parms{"h"} . "</A></H1>\n\n";
    }

    print FP "<H1>$title</H1>\n";

				# Extract list of files
    @files = split(/\#/, $tag_info{"files"});
				# Process them in some reasonable order
    @files = sort(@files);

    foreach $file (@files)
    {
	@tags = ();
				# Name of file
	print FP "<H2>$file ";

				# If there was a description, then add it.
	if(defined($tag_info{"VAR", $file, "DESCRIPTION"}))
	{
	    print FP "(" . $tag_info{"VAR", $file, "DESCRIPTION"} . ")";
	}
	print FP "</H2>\n";

	print FP "<UL>\n";
				# Collect a list of all the tags + file name
	for($i = 0; $i < $tag_info{"num", $file}; ++$i)
	{
				# Only report if not a NSL MODULE.
	    if(!defined $tag_info{"tag NSL flag", $file, $i})
	    {
				# Tag name
		$strg = $tag_info{"tag name", $file, $i};

				# Indicate if it is a function call by adding()
		if($tag_info{"tag type", $file, $i} eq "FUNC"
		   || $tag_info{"tag type", $file, $i} eq "MACRO")
		{
		    $strg .= "()";
		};

		push(@tags, $strg);
	    };
	};

	@tags = sort(@tags);	# Order the tags.

				# Loop through the sorted tags and
				#  report each one.
	foreach $tag (@tags)
	{
	    $tag =~ /(.*)\(\)/ || $tag =~ /(.*)/;
	    print FP "<LI> <A HREF=\"$file.html#$1\">$tag</A>\n";
	};

				# Terminate list
	print FP "</UL>\n<P>\n";
    };
				# Pointers to the other files.

    print FP "<H2> <A HREF=\"tags.all.html\">"
	. $parms{"a"} . "</A></H2>\n";
    print FP "<H2>Back to <A HREF=\"files.html\">" . $parms{"t"} . "</A></H2><P>\n";

				# Footer
    print FP "<P>\n<HR>\n";
    print FP "<H5>C++ to HTML Conversion by <I><A HREF=\"http://www.usc.edu/dept/robotics/personal/af0a/tools/ctoohtml/ctoohtml.html\">ctoohtml</A></I></H5><P>\n";
    print FP "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n";
    print FP "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n";

    print FP "</HTML>\n";
    

    close FP;
};


&interpret_parms();

if(defined $parms{"n"})
{
    print "NSL mode activated.\n";
};

print "Parsing tag file ...\n";
&parse_tag();
print $tag_info{"num"} . " tags found.\n";

print "Postprocessing tag information...\n";
&postprocess_tags();

print "Generating HTML files...\n";
&process_files();

print "Generating Index...\n";
&generate_index("files.html", $parms{"z"}, $parms{"t"});

print "Generating Tag Index...\n";
&generate_all_tags("tags.all.html", $parms{"z"}, $parms{"a"});

print "Generating File-sorted Tag Index...\n";
&generate_file_tags("tags.file.html", $parms{"z"}, $parms{"f"});

print "DONE.\n";

if(!($parms{"d"} & 0x8))
{
    unlink("TAGS");
};

