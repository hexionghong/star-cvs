<pre><h3>SUBROUTINE STRPARSE_RADIX
	          (S,NARGS_max,RADIX,NARGS,ARG,DARG,IARG,VDARG,VIARG)</h3>


*  Inputs:
	CHARACTER*(*) S !Character string containing one or more "arguments"
	                !separated from one another by "separators".
	INTEGER NARGS_max !Maximum number of arguments available to be filled.
	INTEGER RADIX   !Default radix of integers appearing in arguments.

*  Outputs:
	INTEGER NARGS !Number of arguments filled;  .le. NARGS_max.
	CHARACTER*(*) ARG(*) !Filled with NARGS char. arguments from S.
	DOUBLE PRECISION DARG(*) !ARGs translated as D.P. numbers, if possible.
	INTEGER IARG(*) !ARGs translated as integer numbers, if possible.
	LOGICAL VDARG(*) !Set true for each ARG with valid D.P. number.
	LOGICAL VIARG(*) !Set true for each ARG with valid integer number.

*  Description:
*	Parse out up to NARGS_max argument from S and into ARG, DARG and IARG.
*	Argument separators are:
*	space, tab, comma, and equal-sign.  The equal-sign is a special
*	separator in that it is also returned as an argument.  This permits
*	checking externally to STRPARSE_RADIX that equal signs occur where they
*	are supposed to.  To keep spaces or "=" in a single argument, embed
*	the whole argument in double quotes "".

*	Define these values & arrays in the calling routine:
*	INTEGER NARGS_max
*	INTEGER ARG_length
*	PARAMETER (NARGS_max=40) !40 is an example.
*	PARAMETER (ARG_length=80) !80 is an example.
*	INTEGER IARG(NARGS_max)
*	DOUBLE PRECISION DARG(NARGS_max) !This MUST be D.P.
*	CHARACTER*(ARG_length) ARG(NARGS_max)
*	LOGICAL VDARG(NARGS_max),VIARG(NARGS_max)

</pre>
