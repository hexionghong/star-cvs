<HTML>
<PRE>
<H2>file: soc/src/socClasses.cc</H2>


//:Copyright 1995, Lawrence Berkeley Laboratory
//:&gt;--------------------------------------------------------------------
//:FILE:        socClasses.C
//:DESCRIPTION: Service and Object Catalog
//:AUTHOR:      cet - Craig E. Tull, cetull@lbl.gov
//:BUGS:        -- STILL IN DEVELOPMENT --
//:HISTORY:     21jul95-v000a-cet- creation
//:&lt;--------------------------------------------------------------------

//:----------------------------------------------- INCLUDES           --
#include &lt;stream.h&gt;
#include "asuAlloc.h"
#include "asuLib.h"
#include "emlLib.h"
#include "<A HREF="socClasses.hh.html">socClasses.hh</A>"
#include "soc_globals.h"

<B>#define <A NAME="VALID_IDREF">VALID_IDREF(</A>A)  ( (0 &lt;= A && A &lt; myCount && A &lt; <A HREF="#maxCount">maxCount</A>) \</B>
	&& ( myObjs[A] != NULL ) )

//:=============================================== CLASS              ==
// socObject

//:----------------------------------------------- CTORS & DTOR       --
<B>socObject:: <A NAME="socObject">socObject(</A>) {</B>
   EML_MESSAGE("Warning -- This CTOR should never be called.");
   myPtr = NULL; // This must be set in derived CTOR !!!
   myName = new string("UNNAMED");
   myType = new string("UNKNOWN");
   myLock = FALSE;
   soc-&gt;<A HREF="#signIn">signIn</A>(this,myIdRef);
}

//----------------------------------
<B>socObject:: <A NAME="socObject">socObject(</A>long id) {</B>
   EML_MESSAGE("Alert -- This CTOR called only by soc.");
   myPtr = NULL; // This must be set in derived CTOR !!!
   myName = new string("soc");
   myType = new string("socCatalog");
   myLock = TRUE;
   myIdRef = id;
}

//----------------------------------
<B>socObject:: <A NAME="socObject">socObject(</A>const char* <A HREF="#name">name</A>) {</B>
   myPtr = (<A HREF="soc_types.h.html#SOC_PTR_T">SOC_PTR_T</A>)this;
   myName = new string(<A HREF="#name">name</A>);
   myType = new string("socObject");
   myLock = FALSE;
   soc-&gt;<A HREF="#signIn">signIn</A>(this,myIdRef);
}

//----------------------------------
<B>socObject:: <A NAME="socObject">socObject(</A>const char* <A HREF="#name">name</A>, const char* <A HREF="#type">type</A>) {</B>
   myPtr = NULL; // This must be set in derived CTOR !!!
   myName = new string(<A HREF="#name">name</A>);
   myType = new string(<A HREF="#type">type</A>);
   myLock = FALSE;
   soc-&gt;<A HREF="#signIn">signIn</A>(this,myIdRef);
}

//----------------------------------
<B>socObject:: ~<A NAME="socObject">socObject(</A>) {</B>
}

//:----------------------------------------------- ATTRIBUTES         --
<B><A HREF="soc_types.h.html#IDREF_T">IDREF_T</A> socObject::  <A NAME="idRef">idRef</A> () {</B>
   return myIdRef;
}

//----------------------------------
<B>char * socObject::  <A NAME="name">name</A> () {</B>
   char *c = (char*)ASUALLOC(strlen(myName-&gt;show())+1);
   strcpy(c,myName-&gt;show());
   return c;
}

//----------------------------------
<B>char * socObject::  <A NAME="type">type</A> () {</B>
   char *c = (char*)ASUALLOC(strlen(myType-&gt;show())+1);
   strcpy(c,myType-&gt;show());
   return c;
}

//----------------------------------
<B><A HREF="soc_types.h.html#SOC_PTR_T">SOC_PTR_T</A> socObject::  <A NAME="ptr">ptr</A> () {</B>
   return myPtr;
}

//----------------------------------
<B>char * socObject::  <A NAME="soRef">soRef</A> () {</B>
   char *c = (char*)ASUALLOC(strlen(mySOR-&gt;show())+1);
   strcpy(c,mySOR-&gt;show());
   return c;
}

//----------------------------------
<B>void socObject:: <U>lock</U> (unsigned char <A NAME="lock">lock</A>) {</B>     //OVERLOAD CALL: lock: <A HREF="socClasses.cc.html#lock">socClasses.cc(?)</A>, <A HREF="socClasses.cc.html#lock">socClasses.cc(?)</A>
   if(<U>lock</U>){        //OVERLOAD CALL: lock: <A HREF="socClasses.cc.html#lock">socClasses.cc(?)</A>, <A HREF="socClasses.cc.html#lock">socClasses.cc(?)</A>
      myLock = 1;
   }else{
      myLock = 0;
   }
}

//----------------------------------
<B>unsigned char socObject::  <A NAME="lock">lock</A> () {</B>
   return (myLock&gt;0);
}

//:----------------------------------------------- PUB FUNCTIONS      --
<B>STAFCV_T socObject:: <A NAME="attach">attach</A> () {</B>
   myLock++;
   EML_SUCCESS(NORMAL_SUCCESSFUL_COMPLETION);
}

//----------------------------------
<B>STAFCV_T socObject:: <A NAME="release">release</A> () {</B>
   if(myLock&gt;0)myLock--;
   EML_SUCCESS(NORMAL_SUCCESSFUL_COMPLETION);
}

//:----------------------------------------------- PRIV FUNCTIONS     --
// **NONE**

//:=============================================== CLASS              ==
// socCatalog

//:----------------------------------------------- CTORS & DTOR       --
<B>socCatalog:: <A NAME="socCatalog">socCatalog(</A>) </B>
	: <U>socObject(</U>(<A HREF="soc_types.h.html#IDREF_T">IDREF_T</A>)0) {        //OVERLOAD CALL: socObject: <A HREF="socClasses.cc.html#socObject">socClasses.cc(?)</A>, <A HREF="socClasses.cc.html#socObject">socClasses.cc(?)</A>, <A HREF="socClasses.cc.html#socObject">socClasses.cc(?)</A>, <A HREF="socClasses.cc.html#socObject">socClasses.cc(?)</A>, <A HREF="socClasses.cc.html#socObject">socClasses.cc(?)</A>
   myPtr = (<A HREF="soc_types.h.html#SOC_PTR_T">SOC_PTR_T</A>)this;
   myCount = 0;
   <A HREF="#maxCount">maxCount</A> = OBJ_MAX_COUNT;
   myObjs = new socObject* [<A HREF="#maxCount">maxCount</A>];
   <A HREF="soc_types.h.html#IDREF_T">IDREF_T</A> id;
   <A HREF="#signIn">signIn</A>(this,id);
}

//----------------------------------
<B>socCatalog:: ~<A NAME="socCatalog">socCatalog(</A>) {</B>
	for( long i=myCount-1; i&gt;0; i-- ){
  		delete myObjs[i];
	}
  	delete[] myObjs;
}

//:----------------------------------------------- ATTRIBUTES         --
<B>long socCatalog::  <A NAME="count">count</A> () {</B>
   return myCount;
}

//:----------------------------------------------- PUB FUNCTIONS      --
<B>STAFCV_T socCatalog:: <A NAME="deleteID">deleteID</A> (<A HREF="soc_types.h.html#IDREF_T">IDREF_T</A> id) {</B>
   if( !<U>VALID_IDREF(</U>id) ){        //OVERLOAD CALL: VALID_IDREF: <A HREF="soc_macros.h.html#VALID_IDREF">soc_macros.h(?)</A>, <A HREF="socClasses.cc.html#VALID_IDREF">socClasses.cc(?)</A>
      EML_ERROR(INVALID_IDREF);
   }
   if(myObjs[id]-&gt;<U>lock</U>()){        //OVERLOAD CALL: lock: <A HREF="socClasses.cc.html#lock">socClasses.cc(?)</A>, <A HREF="socClasses.cc.html#lock">socClasses.cc(?)</A>
      EML_ERROR(OBJECT_LOCKED);
   }
   delete myObjs[id];
   myObjs[id] = NULL;
   EML_SUCCESS(NORMAL_SUCCESSFUL_COMPLETION);
}

//----------------------------------
<B>STAFCV_T socCatalog:: <A NAME="deleteObject">deleteObject</A> (</B>
		const char * <A HREF="#name">name</A>, const char * <A HREF="#type">type</A>) {
   <A HREF="soc_types.h.html#IDREF_T">IDREF_T</A> id;
   <A HREF="#idObject">idObject</A>(<A HREF="#name">name</A>,<A HREF="#type">type</A>,id);
   if( !<U>VALID_IDREF(</U>id) ){        //OVERLOAD CALL: VALID_IDREF: <A HREF="soc_macros.h.html#VALID_IDREF">soc_macros.h(?)</A>, <A HREF="socClasses.cc.html#VALID_IDREF">socClasses.cc(?)</A>
      EML_ERROR(INVALID_IDREF);
   }
   if(myObjs[id]-&gt;<U>lock</U>()){        //OVERLOAD CALL: lock: <A HREF="socClasses.cc.html#lock">socClasses.cc(?)</A>, <A HREF="socClasses.cc.html#lock">socClasses.cc(?)</A>
      EML_ERROR(OBJECT_LOCKED);
   }
   <A HREF="#deleteID">deleteID</A>(id);
   EML_SUCCESS(NORMAL_SUCCESSFUL_COMPLETION);
}

//----------------------------------
<B>STAFCV_T socCatalog:: <A NAME="findObject">findObject</A> (</B>
		const char * <A HREF="#name">name</A>, const char * <A HREF="#type">type</A>
		, socObject*& obj) {
   <A HREF="soc_types.h.html#IDREF_T">IDREF_T</A> id;
   <A HREF="#idObject">idObject</A>(<A HREF="#name">name</A>,<A HREF="#type">type</A>,id);
   if( !<U>VALID_IDREF(</U>id) ){        //OVERLOAD CALL: VALID_IDREF: <A HREF="soc_macros.h.html#VALID_IDREF">soc_macros.h(?)</A>, <A HREF="socClasses.cc.html#VALID_IDREF">socClasses.cc(?)</A>
      obj = NULL;
      EML_ERROR(INVALID_IDREF);
   }
   if(myObjs[id]-&gt;<U>lock</U>()){        //OVERLOAD CALL: lock: <A HREF="socClasses.cc.html#lock">socClasses.cc(?)</A>, <A HREF="socClasses.cc.html#lock">socClasses.cc(?)</A>
      EML_ERROR(OBJECT_LOCKED);
   }
   obj = myObjs[id];
   EML_SUCCESS(NORMAL_SUCCESSFUL_COMPLETION);
}

//----------------------------------
<B>STAFCV_T socCatalog:: <A NAME="getObject">getObject</A> (<A HREF="soc_types.h.html#IDREF_T">IDREF_T</A> id, socObject*& obj) {</B>
   if( !<U>VALID_IDREF(</U>id) ){        //OVERLOAD CALL: VALID_IDREF: <A HREF="soc_macros.h.html#VALID_IDREF">soc_macros.h(?)</A>, <A HREF="socClasses.cc.html#VALID_IDREF">socClasses.cc(?)</A>
      obj = NULL;
      EML_ERROR(INVALID_IDREF);
   }
   obj = myObjs[id];
   EML_SUCCESS(NORMAL_SUCCESSFUL_COMPLETION);
}

//----------------------------------
<B>STAFCV_T socCatalog:: <A NAME="idObject">idObject</A> (const char * <A HREF="#name">name</A></B>
		, const char * <A HREF="#type">type</A>, <A HREF="soc_types.h.html#IDREF_T">IDREF_T</A>& id) {
// THIS COULD BE IMPLEMENTED BY A HASHTABLE LOOKUP !!
   char *n, *t;
   for( int i=0; i&lt;myCount; i++ ){
      if( myObjs[i] ) {
	 if(  0 == strcmp(n=myObjs[i]-&gt;<A HREF="#name">name</A>(),<A HREF="#name">name</A>) ){
	    if( 0 == strcmp(t=myObjs[i]-&gt;<A HREF="#type">type</A>(),<A HREF="#type">type</A>) 
	    ||  0 == strcmp("-",<A HREF="#type">type</A>) ){
	       id = i;
	       ASUFREE(n); ASUFREE(t);
	       EML_SUCCESS(NORMAL_SUCCESSFUL_COMPLETION);
	    }
	    ASUFREE(t);
	 }
	 ASUFREE(n);
      }
   }
   id = -1;
   EML_ERROR(INVALID_IDREF);
}

//----------------------------------
<B>STAFCV_T socCatalog:: <A NAME="list">list</A> () {</B>

   printf("\n"
"**********************************************************************"
   "\n"
"*************** <A HREF="soc_macros.h.html#SOC">SOC</A> - Service & Object Catalog listing ***************"
   "\n"
"**********************************************************************"
   "\n"
"* IDREF * NAME                    * TYPE                    * POINTER "
    "\n"
"**********************************************************************"
    "\n");
   char *n,*t;
   for( int i=0;i&lt;myCount;i++ ){
      if( myObjs[i] ){
	 printf("* %5d * %-23s * %-23s * %p \n"
	 		,i,n=(myObjs[i])-&gt;<A HREF="#name">name</A>(),t=(myObjs[i])-&gt;<A HREF="#type">type</A>()
			,myObjs[i]);
	 delete[] n; delete[] t;
      } else {
	 printf("* %5d * %-23s * %-23s * - \n"
	 		,i,"**DELETED**","**DELETED**");
      }
   }
   printf(
"**********************************************************************"
   "\n\n");

   EML_SUCCESS(NORMAL_SUCCESSFUL_COMPLETION);
}

//----------------------------------
<B>STAFCV_T socCatalog:: <A NAME="newObject">newObject</A> (const char * <A HREF="#name">name</A>) {</B>
   static socObject* p;
   p = new <U>socObject(</U><A HREF="#name">name</A>,"socObject");        //OVERLOAD CALL: socObject: <A HREF="socClasses.cc.html#socObject">socClasses.cc(?)</A>, <A HREF="socClasses.cc.html#socObject">socClasses.cc(?)</A>, <A HREF="socClasses.cc.html#socObject">socClasses.cc(?)</A>, <A HREF="socClasses.cc.html#socObject">socClasses.cc(?)</A>, <A HREF="socClasses.cc.html#socObject">socClasses.cc(?)</A>
   EML_SUCCESS(NORMAL_SUCCESSFUL_COMPLETION);
}

//----------------------------------
<B>STAFCV_T socCatalog:: <A NAME="signIn">signIn</A> (socObject* obj, <A HREF="soc_types.h.html#IDREF_T">IDREF_T</A>& id) {</B>
   myObjs[myCount] = obj;
   myCount++;
   id = myCount;
   EML_SUCCESS(NORMAL_SUCCESSFUL_COMPLETION);
}

//----------------------------------
<B>STAFCV_T socCatalog:: <A NAME="signOut">signOut</A> (<A HREF="soc_types.h.html#IDREF_T">IDREF_T</A> id) {</B>
   if( !<U>VALID_IDREF(</U>id) ){        //OVERLOAD CALL: VALID_IDREF: <A HREF="soc_macros.h.html#VALID_IDREF">soc_macros.h(?)</A>, <A HREF="socClasses.cc.html#VALID_IDREF">socClasses.cc(?)</A>
      EML_ERROR(INVALID_IDREF);
   }
   if(myObjs[id]-&gt;<U>lock</U>()){        //OVERLOAD CALL: lock: <A HREF="socClasses.cc.html#lock">socClasses.cc(?)</A>, <A HREF="socClasses.cc.html#lock">socClasses.cc(?)</A>
      EML_ERROR(OBJECT_LOCKED);
   }
   myObjs[id] = NULL;
   EML_SUCCESS(NORMAL_SUCCESSFUL_COMPLETION);
}
 
//:----------------------------------------------- PRIV FUNCTIONS     --
//:**NONE**

//:=============================================== CLASS              ==
// socFactory
//:----------------------------------------------- CTORS & DTOR       --
<B>socFactory :: <A NAME="socFactory">socFactory(</A>long <A HREF="#maxCount">maxCount</A>)</B>
		: <U>socObject(</U>) {        //OVERLOAD CALL: socObject: <A HREF="socClasses.cc.html#socObject">socClasses.cc(?)</A>, <A HREF="socClasses.cc.html#socObject">socClasses.cc(?)</A>, <A HREF="socClasses.cc.html#socObject">socClasses.cc(?)</A>, <A HREF="socClasses.cc.html#socObject">socClasses.cc(?)</A>, <A HREF="socClasses.cc.html#socObject">socClasses.cc(?)</A>
   myCount = 0;
   myMaxCount = <A HREF="#maxCount">maxCount</A>;
   idRefs = new <A HREF="soc_types.h.html#IDREF_T">IDREF_T</A> [myMaxCount];
}

//----------------------------------
<B>socFactory :: <A NAME="socFactory">socFactory(</A>const char * <A HREF="#name">name</A>, const char * <A HREF="#type">type</A>)</B>
		: <U>socObject(</U><A HREF="#name">name</A>, <A HREF="#type">type</A>) {        //OVERLOAD CALL: socObject: <A HREF="socClasses.cc.html#socObject">socClasses.cc(?)</A>, <A HREF="socClasses.cc.html#socObject">socClasses.cc(?)</A>, <A HREF="socClasses.cc.html#socObject">socClasses.cc(?)</A>, <A HREF="socClasses.cc.html#socObject">socClasses.cc(?)</A>, <A HREF="socClasses.cc.html#socObject">socClasses.cc(?)</A>
   myCount = 0;
   idRefs = new <A HREF="soc_types.h.html#IDREF_T">IDREF_T</A> [OBJ_MAX_COUNT];
}

//----------------------------------
<B>socFactory :: ~<A NAME="socFactory">socFactory(</A>) {</B>
   delete[] idRefs;
}

//:----------------------------------------------- ATTRIBUTES         --
<B>long socFactory :: <A NAME="count">count</A> () {</B>
   return myCount;
}

//----------------------------------
<B>long socFactory :: <A NAME="maxCount">maxCount</A> () {</B>
   return myMaxCount;
}

//:----------------------------------------------- PUB FUNCTIONS      --
<B>STAFCV_T socFactory :: <A NAME="addEntry">addEntry</A> (<A HREF="soc_types.h.html#IDREF_T">IDREF_T</A> <A HREF="#idRef">idRef</A>) {</B>
   if(myCount &gt;= myMaxCount)return FALSE;
   idRefs[myCount++] = <A HREF="#idRef">idRef</A>;
   EML_SUCCESS(NORMAL_SUCCESSFUL_COMPLETION);
}

//----------------------------------
<B>STAFCV_T socFactory :: <A NAME="deleteEntry">deleteEntry</A> (<A HREF="soc_types.h.html#IDREF_T">IDREF_T</A> <A HREF="#idRef">idRef</A>) {</B>
   for( int i=0;i&lt;myCount;i++ ){
      if( <A HREF="#idRef">idRef</A> == idRefs[i] ){
	 idRefs[i]=0;
         soc-&gt;<A HREF="#deleteID">deleteID</A>(<A HREF="#idRef">idRef</A>);
	 EML_SUCCESS(NORMAL_SUCCESSFUL_COMPLETION);
      }
   }
   EML_ERROR(INVALID_IDREF);
}

//----------------------------------
<B><A HREF="soc_types.h.html#IDREF_T">IDREF_T</A> socFactory :: <A NAME="entry">entry</A> (long n) {</B>
   if(n&lt;myCount){
      return idRefs[n];
   }
   else{
      return 0;
   }
}

//:----------------------------------------------- PROT VARIABLES     --
//:**NONE**
//:----------------------------------------------- PROT FUNCTIONS     --
//:**NONE**
//:----------------------------------------------- PRIV VARIABLES     --
//:**NONE**
//:----------------------------------------------- PRIV FUNCTIONS     --
//:**NONE**

<P>
<P>
<HR>
<H2>Back to <A HREF="files.html">Source File Index</A></H2><P>
<P><HR>
<H5>C++ to HTML Conversion by <I><A HREF="http://www.usc.edu/dept/robotics/personal/af0a/tools/ctoohtml/ctoohtml.html">ctoohtml</A></I></H5>
















































</PRE>
</HTML>
