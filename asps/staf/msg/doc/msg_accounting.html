<h2>MSG Accounting</h2>

The MSG prefixes form the basis of the MSG accounting scheme, which keeps
track of individual messages by their prefixes.  MSG accounting keeps a
count of each defined MSG prefix, records whether a prefix is enabled or
disabled, whether there is a count-limit for any given prefix beyond which
that prefix (and its associated message) is disabled, counts the number of
times a character-string search is made in the list of prefixes for a given
prefix (as opposed to fast-references by ID), and keeps a truncated sample of
the most recent message (beyond the short prefix) for each prefix.  MSG
accounting automatically defines a previously undefined prefix when any
MSG routine is called with that prefix (except for the Direct "flavors" of
five routines, which are intended to deliberately bypass MSG accounting)


<h2>MSG Prefix States </h2>
MSG prefixes exist in one of four states:
<dl>
<dt>Active<dd>Messages with the prefix are displayed, and counted.
<dt>Counting<dd>Messages with the prefix are not displayed, but are counted.
<dt>Inactive<dd>Messages with the prefix are neither displayed nor counted.
<dt>Aborted<dd>The message with the prefix was the one that caused an abort.
</dl>

<h2>MSG Accounting Flavors </h2>

Five routines, Message, MSG_Display, MSG_Display_and_Echo,
MSG_to_LUN, and MSG_to_Journal
each come in two "flavors":  Normal, with full MSG accounting
and control of messages dispatched with the called MSG routine;  and
Direct, which has the suffix "_Out" and no fast-reference ID argument,
which bypasses MSG accounting and control.  The "_Out" flavor always
outputs the message and is useful for producing outputs such as the lines 
of a table, or any output which would not contain an MSG prefix.  To
call a full MSG-accounting routine with a message not containing a prefix
would result in the definition of an unintended prefix;  this would be a
bug condition.  Note that unprefixed lines should always occur only in
conjunction with (and immediately following) a message which does have a 
prefix, (eg, the table's header) so that correct accounting and 
disabling can be done.  For appearance's sake, it is both possible and 
practical to put the prefix on a line of its own, preceding table-header 
lines, for example.  Direct routines (ie, *_Out) should occur only 
within a conditional block which tests first whether a particular 
message (or prefix, actually) is enabled.  Likewise, FORTRAN write 
statements and the like which generate message-strings should only occur 
within such conditional blocks.
<p>


The routines Message, MSG_Display, MSG_Display_and_Echo, MSG_to_Journal
and MSG_to_LUN all perform message-accounting using the specified (and
expected) message prefixes, and will suppress messages if a message is
disabled or if its count-limit is exceeded.  Additionally, Message and
MSG_to_Journal require a journal-file to be opened and enabled in order
to write output to the journal file.
<p>


The routines Message_Out, MSG_Display_Out, MSG_Display_and_Echo_Out,
MSG_to_Journal_Out and MSG_to_LUN_Out do no
message-accounting, and always output their messages, except for
Message_Out and MSG_to_Journal_Out, which require a journal-file to
be opened and enabled in order to write output to the journal file.
<p>

Note that the MSG time-stamp routine also comes in two flavors, 
MSG_Time_Stamp and MSG_Time_Stamp_Out, but in this case the "_Out"
has a different meaning.  MSG_Time_Stamp will not produce a time
stamp if the previous time stamp looks the same as the new one (ie,
if less than one second has elapsed since the last time stamp).
This is very beneficial to readers of journal files, which would
otherwise become clogged with repetitive time stamps under some
conditions.  To provide full flexibility, however, a second
time stamp routine, with the "_Out" appendum, will always make
a node-time stamp.
