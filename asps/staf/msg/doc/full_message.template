*	This is a template for building msg messages; items enclosed in angle brackets <...>
*	are meant to be filled in with application-dependent items.
*	Note that this example uses the "I" class ("Informative"), which is active
*	by default, and has no count limit.  Substitute a "T" for the "I" for the
*	"T" class ("Trace"), which is inactive by default.  "T" class messages are
*	useful in places when detailed dumps or traces are occasionally wanted,
*	but generally not wanted.

*	A string for building multiple-line messages:
	INTEGER             Max_lines_P
	PARAMETER         ( Max_lines_P = <Message Line Count> )
	CHARACTER*132 M132( Max_lines_P )  !"132" may be changed as needed.

*	msg enabled-status test routine, returns logical value:
	LOGICAL MSG_Enabled

*	msg fast-reference IDs for always-active (unless manually shut off) messages:
	INTEGER IDI1, IDI2
	SAVE    IDI1, IDI2          !Keep it static, or it does no good.

	DATA    IDI1, IDI2 / 0, 0 / !Always initialize fast-reference IDs to zero.


	IF (MSG_Enabled( '<Subroutine Name>-I1', IDI1 ) ) THEN
*	  This write is strictly an example -- it's a two-line message:
	  WRITE( M132, 101 ) Junque, Stuff, Nonsense
	  CALL Message( M132, 2, IDI1 ) !2 line message.
	END IF
101	FORMAT('<Subroutine Name>-I1  Junque:  'I11'  Stuff:'E15.8 /
     1	       '                      Nonsense:'I11 )

*	Here's how to make a table -- MSG_Enabled & Message do msg accounting, Message_Out does't:
	IF (MSG_Enabled( '<Subroutine Name>-I2', IDI2 ) THEN
	  CALL Message( '<Subroutine Name>-I2  This is a pedagogical table:', 1, IDI2 )
	  DO Irow = 1, Nrows
	    WRITE( M132, 102 ) Irow
	    CALL Message_Out( M132, 1 )  !Use Message_Out here, since no msg accounting
	                                 !should be done for table rows.
	  END DO
	END IF
102	FORMAT( '                      Row 'I3' ----------------------' )
