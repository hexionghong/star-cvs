

			STAR Return-Condition

			And Message Handling

			 April 15,  1993




			   Introduction

This document describes the STAR msg Message Handling package.  A 
description of the source files and how to build and link msg on VMS and 
Unix platforms is contained in Appendix A.

In this document, a "return-condition" is any item returned by a called 
subroutine to its caller which indicates in some well-defined way the 
status of the operation performed, or the detection of an "abnormal" 
situation by the called subroutine, and which must then be "handled" by 
the caller.  An "abnormal" situation is one which may possibly require 
operator action or concern for possible future action.   See Appendix B 
for more information on STAR return-conditions.

"Message Handling" in this document means the display and journal-logging 
of any messages whose purpose is to inform software operators in real-time 
of possible action that must be taken by the operators, and affects only
"permanent" code, installed or intended to be installed in the STAR 
software library(s) or otherwise for use within the "public" domain of the 
STAR collaboration.  This does not pertain to such things as interactive 
dialogs, general status displays, etc.  It is not the intention here to 
restrict the usage of any "temporary" displays or other "personal" 
debugging aids, with the sole provision that such things must not find 
their way into the public domain, including (and especially) the STAR 
library.

The msg routines have the prefix "MSG_", except for "MESSAGE" (and "
MESSAGE_OUT").  "MESSAGE" calls are ubiquitous, and as such are an 
exception to the general STAR rule, which would require it to have the 
somewhat ridiculous name "MSG_MESSAGE".


	                     Messages

Messages consist of one or more lines of ASCII characters with no more 
that 132 characters per line.  The messages may be completely described in 
FORTRAN DATA or PARAMETER statements, or the C equivalent, or they may be 
generated in real time using FORTRAN "internal files" (ie, character 
strings instead of logical unit numbers), or the C equivalent.  Messages 
may not be generated in any way which directly produces output, such as 
with a FORTRAN WRITE to a logical unit, but only as character strings 
which are then passed as arguments to actual I/O routines (ie, the 
routines in the msg package).  FORTRAN WRITE statements, to "internal 
files" (ie, character strings instead of LUNs), are generally used for 
the purpose of generating the messages to be displayed.  Multiple lines 
are implemented as multiple-dimensioning of the character string used 
to contain the message, eg: 

	CHARACTER*132 M132    !Defines a one-line message space.

	CHARACTER*132 M132(6) !Defines a six-line message space.

FORTRAN formatted WRITE statements start writing to the next "line" in 
such a character string whenever the new record character "/" is 
encountered.

	                   msg Prefixes

Messages must all contain, in the beginning of the message, a unique 
identifier, or "prefix", which serves to uniquely and unambiguously 
identify the source, in the code, of the message.  The prefix should (but 
need not, as far as the msg package is concerned) be the name of the 
routine which generates the message, followed by a dash "-", and the dash 
followed by a character or characters which uniquely identifies the source 
of the message within that routine.  The "body" of the message, if there 
is one, must be separated from the prefix by one or more ASCII spaces, 
tabs , newlines (ie, carriage return characters, ASCII 10.), formfeeds 
(ASCII 12 .) or nulls (ASCII 0.).


	                  msg Accounting

The msg prefixes form the basis of the msg accounting scheme, which keeps
track of individual messages by their prefixes.  msg accounting keeps a
count of each defined msg prefix, records whether a prefix is enabled or
disabled, whether there is a count-limit for any given prefix beyond which
that prefix (and its associated message) is disabled, counts the number of
times a character-string search is made in the list of prefixes for a given
prefix (as opposed to fast-references by ID), and keeps a truncated sample of
the most recent message (beyond the short prefix) for each prefix.  msg
accounting automatically defines a previously undefined prefix when any
msg routine is called with that prefix (except for the Direct "flavors" of
four routines, which are intended to deliberately bypass msg accounting)


	              msg Accounting Flavors 

Four routines, MESSAGE, MSG_DISPLAY, MSG_DISPLAY_AND_ECHO and 
MSG_TO_LUN come in two "flavors":  Normal, with full msg accounting
and control of messages dispatched with the called msg routine;  and
Direct, which has the suffix "_OUT" and no fast-reference ID argument,
which bypasses msg accounting and control.  The "_OUT" flavor always
outputs the message and is useful for producing outputs such as the lines 
of a table, or any output which would not contain an msg prefix.  To
call a full msg-accounting routine with a message not containing a prefix
would result in the definition of an unintended prefix;  this would be a
bug condition.  Note that unprefixed lines should always occur only in
conjunction with (and immediately following) a message which does have a 
prefix, (eg, the table's header) so that correct accounting and 
disabling can be done.  For appearance's sake, it is both possible and 
practical to put the prefix on a line of its own, preceding table-header 
lines, for example.  Direct routines (ie, *_OUT) should occur only 
within a conditional block which tests first whether a particular 
message (or prefix, actually) is enabled.  Likewise, FORTRAN write 
statements and the like which generate message-strings should only occur 
within such conditional blocks.


The routines MESSAGE, MSG_DISPLAY, MSG_DISPLAY_AND_ECHO, MSG_TO_JOURNAL
and MSG_TO_LUN all perform message-accounting using the specified (and
expected) message prefixes, and will suppress messages if a message is
disabled or if its count-limit is exceeded.  Additionally, MESSAGE and
MSG_TO_JOURNAL require a journal-file to be opened and enabled in order
to write output to the journal file.


The routines MESSAGE_OUT, MSG_DISPLAY_OUT, MSG_DISPLAY_AND_ECHO_OUT,
MSG_TO_JOURNAL_OUT, MSG_TO_LUN_OUT and MSG_TIME_STAMP do no message-
accounting, and always output their messages, except for MESSAGE_OUT and
MSG_TO_JOURNAL_OUT, which require a journal-file to be opened and
enabled in order to write output to the journal file.


			msg Enabled Tests

There are two msg routines which return the enabled-status of a specified
message-prefix:  MSG_ENABLED, which performs full msg accounting and
increments the specified message-prefix's counter each time it is called
(whether the prefix is enabled or not), and MSG_ENABLED_TRACE, which only
tests the enabled status of a prefix, but never increments any counters
or anything else.  MSG_ENABLED is meant to define a conditional msg
block in which various (possibly CPU-expensive) operations are performed,
for the purpose of generating an informative message when a certain
condition arises, but which may be disabled if desired.  If a prefix
has not yet been defined to the msg package when first encountered by
a MSG_ENABLED call, it is defined, and enabled.  Only Direct routines (ie,
*_OUT) routines should be called within a MSG_ENABLED conditional block,
otherwise double-counting of prefix occurances will result.  On the other
hand, MSG_ENABLED_TRACE exists for a different purpose, namely to provide
a mechanism for inserting normally-invisible debugging-type code-flow
trace-messages, which are enabled only when specifically requested.
MSG_ENABLED_TRACE will define a previously undefined prefix, but sets it
to the disabled state.  Only msg routines which do full msg-accounting
should be called from within a MSG_ENABLED_TRACE conditional block, else
the prefix will not be counted.


	             msg Time and Node Stamps

The routines MESSAGE, MESSAGE_OUT, MSG_TO_JOURNAL and MSG_TO_JOURNAL_OUT
all put a date-time-node-stamp in the journal file, if opened and enabled,
preceding the output message.  This date-time-node stamp is omitted if
the stamp is identical to the previous stamp used;  msg outputs a stamp
to the journal file at most once per second, unless messages from different
nodes occur.  In addition to the date, time and node appearing on the stamp,
the total elapsed real and CPU time, since the MSG_INI call, also appear on
the stamp.  The elapsed real time may be reset with a call to STRELA0, and
the elapsed CPU time reset with STRCPU0 (see str.doc).


                      msg Aborts

Each message-prefix, when first defined, is given an "abort limit"
of zero, which means there is no abort limit.  By setting an abort
limit with the subroutine MSG_Set_Abort_Limit( <Prefix>, <Limit> ),
or with MSG_Set_by_Command( <Command> ), with <Command>:

   ABORT <Prefix>=<Limit>

will cause msg to abort program execution when the specified prefix
has counted up to the abort limit.  A message indicates the abort,
and an msg summary is output to the journal file, if active.


	         msg Summary Output

A call to MSG_Summary( LUN ) will output the msg summary table to
logical unit LUN.  A call to MSG_Summary_Event( LUN, Events ),
with caller-specified event-count Events, produces the same table
but with an extra column, being the number of counts of each prefix
divided by Events, if not zero.  The summary has a one-line entry
for each prefix, with information about each organized into columns.
The columns are:

	1)  Message-Prefix & Truncated Sample of last occurance  -- this is
	(up to) 64 characters of the last message dispatched through msg
	which has this prefix.

	2)  Counts  -- this is the number of occurances of this prefix while
	counting was enabled for this prefix (Counting can be disabled).

	2a) Counts/evt -- MSG_Summary_Event only -- this is the occurance
	frequency, with respect to a caller-specified event count.

	3)  Limit   -- this it the count-limit, after which messages with this
	prefixes stop producing output.  They continue to count.

	4)  Lookups  -- this is the number of times each prefix had to be
	looked up, as a character-string search, in the prefix table.  Optimal
	usage puts this at (max) one per prefix, though infrequently occuring
	messages can be harmlessly specifed (in the MESSAGE call, for example)
	with a fast-reference ID of -1 (no ID), in which case Lookups = Counts.

	5)  AbortLimit  -- this is the count beyond which (if AbortLimit is
	positive) program execution will terminate from within msg.

	6)  State   --  One of:

	      Active  Prefix is active -- messages are displayed and counting.
	    Counting  Prefix is inactive, but counting continues.
	    Inactive  Prefix is inactive -- messages are neither displayed nor
	              counted.
	     Aborted  Prefix exceeded the abort limit and aborted the program.
	              Only one prefix will have this state, at most, and only
	              if the table was produced by an msg abort.


The number of lines in a summary output page defaults to 66, but may be set
with a call to MSG_Set_Summary_Page_Length( <Lines> ) .



	              msg Template files

There are currently three template files, ready to be included into application
and then editted as needed.  They are:

	msg_initialization.template  --  How to initialize msg, and set msg items.
	msg.template                 --  How to make and use messages.
	msg_trace.template           --  How to make and use dormant trace messages.



	              msg Return Conditions

STAR Standard Return Conditions for the msg routines are defined in the
logical file:
	                 msg_ret_inc ,

which is MSG_RET.INC on VMS.  These routines are defined in the file
MSG_REF:msglib.for (VMS) or $msg_ref/msglib.f (Unix).  This include
file is generally not needed, however, since those routines which may
fail, such as MSG_RC_JOURNAL_OPEN, either fail or not, and therefore
are also available as FORTRAN logical functions (with a different name),
eg:

   MSG_RC_JOURNAL_OPEN returns either MSG_OPENED_RC or MSG_NOT_OPENED_RC,
   MSG_JOURNAL_OPEN returns either .true. or .false. .
   MSG_RC_JOURNAL_OPEN and MSG_JOURNAL_OPEN are otherwise identical.

A sample program, which is the msglib test-program, is available in
the file MSG_REF:msgt.for (VMS) or $msg_ref/msgt.f (non-VMS).







	                   Appendix A

	      Building and Linking with the msg Library


The sources are resident on rsgi00.rhic.bnl.gov and are maintained with 
cvs/rcvs.  The msg files are:

msglib.f 	User-callable msg routines are defined here.
msgsub.f 	msg internal-accounting routines are defined here.

msg.inc		msg internal COMMON and PARAMETER definitions.
msg_sgi.inc	msg platform-specific definitions for SGI.
msg_aix.inc	msg platform-specific definitions for IBM AIX (RS 6000).
	        (out of date.)
msg_3090.inc	msg platform-specific definitions for IBM AX (3090).
	        (out of date.)
msg_hp.inc	msg platform-specific definitions for HP (720/750).
	        (out of date.)
msg_vms.inc	msg platform-specific definitions for VMS.
msg_ret.inc	msg Return Code (STAR) definitions.
	        (Not yet from STAR RC database.)

msg_inc		Symbolic link to msg.inc .
msg_native_inc	Symbolic link to one of the platform-specific msg include
		files, eg:  msg_sgi.inc .
msg_ret_inc	Symbolic link to msg_ret.inc .
		(Symbolic links are made by Makefile -- needs to be 
		modified for non-SGI platforms.)

msglib.a	Non-debug archive containing all of the msg routines.
msglib_dbg.a	Debug archive containing all of the msg routines, compiled
		with the "-g" switch.

Makefile	msg make file -- used with "msg", "dbg" or "all", to make
		msglib.a, msglib_dbg.a, or both.

makemsg.com     VMS command file to build MSGLIB.OLB and MSGLIB_DBG.OLB .
msg_define.com  VMS command file to define msg logicals, except include 
		files.
msg_include_define.com  VMS command file to define msg include-file 
		logicals.

msg.doc		This document.
msglib.doc	Description of msglib.f routines.
msgsub.doc	Description of msgsub.f routines.




			To build msg on VMS:

	a) Use ftp to get the files from rsgi00.rhic.bnl.gov .
	   Working from rsgi00.rhic.bnl.gov, ftp'ing to VMS:
		ftp command:			description:
	        cd <VMS msg directory>          change directory on the
		                                VMS end.
	        prompt                          disable prompting for
	                                        mget/mput.
	        nmap $1.f $1.for                *.f files become *.for
	        mput *.f                        put all *.f files onto VMS as
	                                        *.for files.
	        nmap                            disable filename mapping.
	        mput *.inc                      put include files.
	        mput *.com                      put VMS command files.
	        mput *.doc                      put documentation files.

	b) Logon the VMS machine.  Set default (change directory) to the
	msg directory.

	c) Edit MSG_DEFINE.COM to define the logical MSG_REF, which should
	be the msg directory.  Sample lines are included, commented out.

	d) Set the default directory to be MSG_REF .

	e) Execute MAKEMSG.COM .   The msg libraries should now be built.


			To link msg on VMS:

	Link with the libraries MSGLIB.OLB and STRLIB.OLB (see STRLIB.DOC
	in STR_REF -- some calls from within MSGLIB.OLB to STRLIB.OLB 
	routines are made, such as standard date & time routines), 
	specifying MSGLIB before STRLIB in the link-string.  Any calls to 
	MSGLIB routines which return STAR-standard-return-conditions should
	be checked against one or more of the return-conditions described
	in this manual, under the subroutine's description, and defined 
	in the include file "msg_ret_inc".





	                  To build msg on Unix:

	a) Use ftp to get the files from rsgi00.rhic.bnl.gov .
	   Working from rsgi00.rhic.bnl.gov, ftp'ing to another Unix node:
		ftp command:			description:
	        cd <msg directory>              change directory to the
	                                        source-code target.
	        prompt                          disable prompting for
	                                        mget/mput.
	        mput *.f                        put all *.f files
	        mput *.inc                      put include files.
	        mput *.com                      put VMS com-files
	                                        (optional).
	        mput *.doc                      put documentation files.

	b) Logon the Unix machine.  Change directory to the msg directory.

	c) Execute Makefile, with "all" (eg: "make all"), to rebuild both
	   the debug and non-debug vesions.  The msg libraries should now
	   be built.


			To link msg on Unix:

	a) Link with the libraries libmsg.a and libstr.a (see str.doc
	in ~/star/str  -- some calls from within libmsg.a to libstr.a
	routines are made, such as standard date & time routines),
	specifying libmsg.a before libstr.a in the link-string.  Any calls
	to libmsg.a routines which return STAR-standard-return-conditions
	should be checked against one or more of the return-conditions
	described in this manual, under the subroutine's description, and
	defined in the include file "msg_ret_inc".



	                   Appendix B

	The STAR Standard for Return-Condition-Passing Subroutines


This appendix describes the criteria that a subroutine must satisfy in
order to be classified as a STAR-standard return-condition-passing 
subroutine.

Return conditions must always be single (32-bit) word integer values;  a
return condition may not ever be an array.

When a FORTRAN-callable subroutine has a return condition, it must always 
be passed back to the caller as the value of an INTEGER FUNCTION;  that 
is, such subroutines must be defined as INTEGER FUNCTION subroutines.
Furthermore, such subroutines must contain in their names the three 
characters "rc_" or "RC_", following the underscore after the STAR-
standard three-letter package prefix, eg: 

	INTEGER FUNCTION pkg_rc_subname .

Not all INTEGER FUNCTION subroutines are necessarily STAR-standard
return-condition-passing subroutines, nor are all INTEGER FUNCTION
subroutines' returned FUNCTION values necessarily return conditions;
the "rc_" serves to unambiguously identify a particular subroutine as a 
STAR-standard return-condition passing subroutine.  A routine may 
absolutely not contain the "rc_" in its name after the package-prefix
unless it is a STAR-standard return-condition-passing subroutine in full 
compliance with this document.

FORTRAN REAL, LOGICAL and CHARACTER FUNCTION subroutines are not 
forbidden by this document, but neither their returned values nor any of 
their arguments are ever to be regarded as return conditions, and may not,
therefore, ever reflect an "abnormal" condition.  "Plain" subroutines 
are also not forbidden, but they may never have a return condition as 
one of the arguments.  A FUNCTION subroutine which returns something 
other than a return condition as its FUNCTION value, and which passes 
back a return condition as one of its calling arguments is not allowed. 

Return conditions must be well-defined, constant values and must never 
be used as some kind of a "success type", "success count" or other 
construct;  "types", "counts" or constructs deserve their own calling 
arguments, and ought not to be mixed in with the return condition.  
Return conditions must all be defined as FORTRAN INTEGER PARAMETERs in 
INCLUDE files;  these INCLUDE files will be generated automatically in a 
manner described in more detail below.  The return-conditions' symbolic
(PARAMETER) names shall all have the suffix "_rc".

Return conditions are recognized as falling into four general catagories
of severity:

	S:  Success
	I:  Informative return
	W:  Warning
	E:  Error

Generally, an "informative return" should be used to indicate some kind of
normal termination;  for example, a routine being called from within a loop
might exhaust its data in a normal fashion and indicate to the caller 
that it's time to exit the loop.  Operator intervention is never required
in this case. 

A "warning" is one in which some real compromise may have occurred, such
as partial or complete loss of data in a buffer, but one in which some
kind of automatic recovery or continuation occurs;  operator intervention
may or may not be required, depending on frequency and success of automatic
recovery.

An "error" is one in which operator intervention is assumed to be required.
It is not forbidden for code to attempt to recover from such failures, but
operators should always be notified of these. 


A database platform will be used to perform certain operations (Doug 
Olson has a working version with INFORMIX), and will require data-entry 
sessions during which the following information will be entered into the 
database for each STAR software package: 

1) the three-letter package prefix,

2) the symbolic name of each possible return-condition, including the
normal-return condition,

3) the single-letter severity-level (S, I, W or E) of each possible
return-condition,

4) a one or two line terse message to be associated with each possible
return-condition, and:

5) a verbose description of each possible return-condition, including a
list of possible remedies.

Item 5) is intended to form the basis of some yet-to-be-specified online
help capability.


The database then assigns a unique, STAR-wide global value, containing
severity-level information, to each return-condition in each package, and
generates the following files: 


1) an INCLUDE file, named "pkg_rc_values.inc" (where "pkg" stands for the
three-letter package-prefix) which defines all of the possible return
conditions for each package as FORTRAN integer parameters, 


2) an INCLUDE file, named "scv_rc_all_values.inc" which defines all of the
possible return conditions for all of the packages as FORTRAN integer
parameters, 

3) a FORTRAN file, named "scv_messages.for", which defines a subroutine 
which will return a return-condition's one or two line message when 
called with a return-condition as an argument, and: 

4) (in the future) a FORTRAN file, named "scv_describe.for", which will 
define a subroutine which will display a return-condition's verbose 
description when called with a return-condition as an argument, in an as-
yet-to-be-decided fashion. 

An additional subroutine is provided, scv_state, which is used to 
determine the severity-level of a return-condition.  scv_state is not
described here.


The return-condition values (automatically) defined in the INCLUDE files 
are defined as FORTRAN PARAMETERs (type INTEGER), each with the three-
letter package-prefix followed by an underscore and the symbol name as 
entered in the database, followed by the suffix "_rc".


Each possible return condition value must be fully described in the 
documentation for the subroutine in addition to the verbose description 
and terse message provided to the database;  this description may be 
generated automatically by the database from the verbose description or 
terse message (not yet specified). 




	                 Appendix C

		      msg Coding Sample


	Link with this on VMS:

 $ LINK MSG_SAMPLE,MSG_REF:MSGLIB/LIB,STR_REF:STRLIB/LIB


	Link with this on Unix (modify library directory references):

 f77 msg_sample.o -L./ -L../str -L../msg -lmsg -lstr -o msg_sample



	PROGRAM MSG_Sample

	IMPLICIT NONE

*  Functional description:
*	MSG_SAMPLE contains a collection of calls to MSGLIB routines,
*	assembled together to make a working, if otherwise meaningless,
*	example.

*	Declaration of message variables used in coding sample:

	INTEGER ID511,ID514,ID515,ID516

	INTEGER PAD_LIST_LUN_P
	PARAMETER (PAD_LIST_LUN_P=17) !Listing/message-journal LUN.
	INTEGER PADHIT_LUN_P
	PARAMETER (PADHIT_LUN_P=18) !An ASCII output file.

	INTEGER JOURNAL_LUN

	INTEGER File_Ver
	CHARACTER*80 File_Name_Ver

	CHARACTER*80 M80(20)

*	Function declations:
	LOGICAL MSG_JOURNAL_CLOSE,MSG_JOURNAL_OPEN !From MSGLIB
	LOGICAL MSG_ENABLED, MSG_ENABLED_TRACE
	LOGICAL STROPENVER                         !From STRLIB

*	Data statements for message ID variables, initialized to zero
*	to force prefix-lookup on first call:
	DATA ID511,ID514,ID515,ID516/4*0/


*	Set up the STAR message library -- specify journal file LUN:

*	 (Calling argument is journal file LUN, or zero,
*	  if no journal file is desired.)

	JOURNAL_LUN=PAD_LIST_LUN_P !Make this the journal LUN.
	CALL MSG_INI(JOURNAL_LUN)

*	Open debug/trace/result-summary/message-journal file.

*	Use your favorite OPEN statement, or equivalent, or the following,
*	machine-independent method, which will NOT fail if the file already
*	exists, and will NOT delete an existing file of the same name:

*	Note:  If openned this way under Unix, and if the specified file
*	already exists, a slightly different file name will be openned,
*	one which is the specified file name with a VMS-like version-
*	string appended (except a "." is used instead of a ";").

	IF (.NOT.MSG_JOURNAL_OPEN('gh.lst')) THEN !Open failure.
	  WRITE(M80,514) 'gh.lst'
*	  Display one line of M80 on the terminal only (no attempted entry in
*	  the journal), using the full MSGLIB accounting (ie, manual and
*	  automatic enable/disable capabilities built into MSGLIB):
	  CALL MSG_DISPLAY(M80,1,ID514)
	END IF !.NOT.MSG_JOURNAL_OPEN('gh.lst')
514	FORMAT('GH-E14  Open failure on journal file: ['A'].')


*	Normally disabled "trace" messages -- these messages will not
*	output unless first enabled with a call to MSG_ENABLE:

*	{Can also be done with MSG_SET_BY_COMMAND, with file-read
*	 ASCII commands.  See MSG_SET_BY_COMMAND.}

*	{A limited wildcard-capability exists for specifying the prefix;
*	 all messages from a given subroutine, for example, can be disabled
*	 with one call.}

*	{De-comment to enable:}
*	CALL MSG_ENABLE('PADGEN-Trace1')
*	CALL MSG_ENABLE('PADGEN-Trace2')
*	etc.



*	Normally limited error messages -- these messages will 
*	automatically disable themselves when the specified number of
*	occurances of a particular messages has been reached:

*	{Can also be done with MSG_SET_BY_COMMAND, with file-read
*	 ASCII commands.  See MSG_SET_BY_COMMAND.}

*	{A limited wildcard-capability exists for specifying the prefix;
*	 all messages from a given subroutine, for example, can be limited
*	 with one call.}

	CALL MSG_SET_LIMIT('PADGEN_GETHIT_ROW-E1',5)
	CALL MSG_SET_LIMIT('PADGEN_CHECK_SRC-E1',5)
	CALL MSG_SET_LIMIT('PADFIT_Set_Pfixed-E1',20)
*	etc.


*	Output this message both on the terminal and to the journal --
*	if the journal file were not opened, or if journal-logging were
*	not enabled, this would output only on the terminal:

	WRITE(M80,511)
	CALL MESSAGE(M80,2,ID511)

511	FORMAT('GH-E11 2-line error sample.'/
     1	       '       Second line of message.')



*	Generate a machine-independent version-appended file name (see 
*	strlib.for), or use your own, favorite OPEN statement
*	(CARRIAGECONTROL=LIST forces VMS to dispense with the FORTRAN
*	carriage control character, and is ignored on other platforms).

*	{This gets around the problem with Unix which does not permit
*	 openning new files if old ones of the same name already exist, 
*	 requiring careful and time-consuming house-cleaning before each 
*	 run.  If the file exists and the OPEN (not seen directly by the
*	 caller) therefore fails, STROPENVER appends a VMS-like version-
*	 string to the file name and keeps trying until it succeeds,
*	 or hits a "limit", here 32767, at which point it fails and 
*	 returns false --  this all goes very quickly.  A template exists
*	 for the STROPENVER call, under str_ref, called:
*	          stropenver.template }

	IF (.NOT.STROPENVER(PADHIT_LUN_P,'gh.pad'
     1	    ,'CARRIAGECONTROL=LIST,STATUS=NEW'
     2	    ,32767,'.',File_Ver,File_Name_Ver)   ) THEN !Open failure:
	  WRITE(M80,515) 'gh.pad',File_Ver
	  CALL MESSAGE(M80,1,ID515)
	END IF
515	FORMAT('GH-E15  Open failure on file: ['A'], version:'I11)



*	Write header to raw data (pad hits) file.
*	Bypass MSG accounting by using the "_OUT" flavor
*	of MSG_TO_LUN -- ie, ALWAYS output this:

	WRITE(M80,101)
	CALL MSG_TO_LUN_OUT(M80,1,PADHIT_LUN_P)

101	FORMAT(' Sec Row Pad  TDC  ADC  TID   TJD') !For PADHIT_LUN_P

	CLOSE(UNIT=PADHIT_LUN_P) !Close the "results" file.



	WRITE(M80,516) 1,2,3,4,5,6,7,8,9 !Just some dummy values.
	CALL MESSAGE(M80,2,ID516)

516	FORMAT('GH-E16-Padhit_Write_Error  Rowhits:'I8
     1	     ' Sector:'I8' Row:'I8/
     2	       '       Hit:'I8' Pad:'I6' TDC:'I8' ADC:'I8
     3	     ' ID:'I6'/'I6)



*	Summary of messages:
	CALL MSG_SUMMARY(6) !On terminal.
	CALL MSG_SUMMARY(JOURNAL_LUN) !In Journal/Listing file


*	Close the journal file and exit:

	IF (.NOT.MSG_JOURNAL_CLOSE()) THEN
*	  Close failure, whatever that means:
	  STOP 'End of msg Sample, Journal file not closed.'
	ELSE
*	  Close success:
	  STOP 'End of msg Sample, Journal file closed.'
	END IF

	END
