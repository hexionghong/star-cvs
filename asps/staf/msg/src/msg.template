

*	msg.template -- the msg message-calls template.

*	This is an msg template -- replace items enclosed in <brackets> with application-
*	specific values and names.  Some numbers, such as message-lengths of 132, may be
*	changed or kept, as needed;  the values shown are the most general or the most
*	common and almost always can be used as-is.  Inline comments indicate which of
*	these may be safely changed.  3 or more blank lines indicate application-specific
*	code may reside there.

*	Application-specified values:
*	<Subroutine Name>     CHARACTER*(*)
*	<Count Limit>         INTEGER*4
*	<Abort Limit>         INTEGER*4
*	<Message Line Count>  INTEGER*4



*	A string for building multiple-line messages:
	INTEGER Max_lines_P
	PARAMETER (Max_lines_P = <Message Line Count>)
	CHARACTER*132 M132(Max_lines_P)                   !"132" may be changed as needed.

*	msg fast-reference IDs for messages:
	INTEGER IDI1, IDI2, IDE1
	SAVE IDI1, IDI2, IDE1       !Keep it static, or it does no good.
	LOGICAL MSG_Enabled



	DATA IDI1, IDI2, IDE1 / 0, 0, 0 /   !Always initialize fast-reference IDs to zero.


	Here's the simplest message call (eg, for an error);  "-1" means no fast-reference ID:
	CALL Message( '<Subroutine Name>-E1  This is a pedagogical error message', 1, -1 )

	Here's a more CPU-efficient way to do the same thing -- not always necessary:
	CALL Message( '<Subroutine Name>-E1  This is a pedagogical error message', 1, IDE1 )



*	Here's how to generate a message with a WRITE statement, and
*	with the WRITE executing only if the message is enabled:

*	  Note:  Use Message inside of a MSG_Enabled block, since
*	  MSG_Enabled performs msg accounting only if it returns false.
*	  If the prefix '<Subroutine Name>-T1' is undefined when this
*	  call occurs, it gets defined, and is initialized to be Active,
*	  unless all messages have been disabled with a wildcard-name.

	IF (MSG_Enabled( '<Subroutine Name>-T1', IDI1 ) ) THEN
*	  This write is strictly an example -- it's a two-line message:
	  WRITE( M132, 101 ) Junque, Stuff, Nonsense
	  CALL Message( M132, 2 ) !2 line message -- note that "_Out" takes no ID.
	END IF
101	FORMAT('<Subroutine Name>-T1  Junque:  'I11'  Stuff:'E15.8 /
     1	       '                      Nonsense:'I11 )



	Here's how to make a table -- MSG_Enabled & Message do msg accounting, Message_Out does't:
	IF (MSG_Enabled( '<Subroutine Name>-I2', IDI2 ) THEN
	  CALL Message( '<Subroutine Name>-I2  This is a pedagogical table:', 1 )
	  DO Irow = 1, Nrows
	    WRITE( M132, 102 ) Irow
	    CALL Message_Out( M132, 1 )  !Use Message_Out here, since no msg accounting
	                                 !should be done for table rows.
	  END DO
	END IF
102	FORMAT( '                      Row 'I3' ----------------------' )



*****************************************************************************************
*	These calls generally occur outside the subroutine containing the message:

*	Disable this trace message from within the code:
	CALL MSG_Disable( '<Subroutine Name>-I1' )

*	Or, disable this trace message with an ASCII command:
	CALL MSG_Set_by_Command( 'DISABLE <Subroutine Name>-I1' )

*	Or, specify an abort-count, after which program execution terminates:
	CALL MSG_Set_Abort_Limit ( '<Subroutine Name>-I1', <Abort Limit> )



*	Enable this message & specify no count-limit, from within the code:
	CALL MSG_Enable( '<Subroutine Name>-I1' )

*	Or, enable this message & specify no count-limit, with ASCII commands:
	CALL MSG_Set_by_Command( 'ENABLE <Subroutine Name>-I1' )
	CALL MSG_Set_by_Command( 'LIMIT  <Subroutine Name>-I1=<Count Limit>' )
*****************************************************************************************
