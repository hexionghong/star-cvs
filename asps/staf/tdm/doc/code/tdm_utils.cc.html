<HTML>
<PRE>
<H2>file: tdm/src/tdm_utils.cc</H2>


/*:Copyright 1996, Lawrence Berkeley National Laboratory
*:&gt;---------------------------------------------------------------------
*:FILE:		tdm_utils.C
*:DESCRIPTION:	Utility functions  for AMI package.
*:AUTHOR:	cet - Craig E. Tull, cetull@lbl.gov
*:BUGS:		-- STILL IN DEVELOPMENT --
*:HISTORY:	06feb96-v001a-cet- moved from AMI to TDM
*:HISTORY:	19dec95-v000a-cet- creation
*:&lt;---------------------------------------------------------------------
*/

/*-------------------------------------------- INCLUDES             --*/
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include "<A HREF="tdm_types.h.html">tdm_types.h</A>"
#include "asuAlloc.h"

/*-------------------------------------------- MACROS               --*/
/*-------------------------------------------- TYPEDEFS             --*/
/*-------------------------------------------- GLOBALS              --*/
/*-------------------------------------------- PROTOTYPES           --*/

/*
*:&gt;---------------------------------------------------------------------
*:ROUTINE:      tdm_cvtDst2st
*:DESCRIPTION:  Convert DSL table to 2-struct (TAS) table.
*:ARGUMENTS:    DS_DATASET_T *pT	- DSL table
*:ARGUMENTS:    <A HREF="table_header.h.html#TABLE_HEAD_ST">TABLE_HEAD_ST</A> *& tbl_h	- table header struct
*:ARGUMENTS:    char *& tbl_d		- table data struct array
*:RETURN VALUE: TRUE or FALSE
*:&lt;---------------------------------------------------------------------
*/
<B>int <A NAME="tdm_cvtDst2st">tdm_cvtDst2st(</A>DS_DATASET_T *pT</B>
		, <A HREF="table_header.h.html#TABLE_HEAD_ST">TABLE_HEAD_ST</A> *& tbl_h, char *& tbl_d)
{
   <A HREF="table_header.h.html#TABLE_HEAD_ST">TABLE_HEAD_ST</A> header;
   char *name=(header.name);
   char *type=(header.type);
   bool_t result;
   char* pData=NULL;

   if( !dsIsTable(&result,pT)
   ||  !result
   ||  !dsTableName(&name,pT)
   ||  !dsTableTypeName(&type,pT)
   ||  !dsTableMaxRowCount((size_t*)(&(header.maxlen)),pT)
   ||  !dsTableRowCount((size_t*)(&(header.nok)),pT)
   ||  !dsTableRowSize((size_t*)(&(header.rbytes)),pT)
   ||  !dsTableDataAddress(&pData,pT)
   ){
      dsPerror("cannot convert DSL table to TAS table");
      return FALSE;
   }
   tbl_h = (<A HREF="table_header.h.html#TABLE_HEAD_ST">TABLE_HEAD_ST</A>*)ASUALLOC(sizeof(header));

/*- WARNING - Following strncpy's write \000 into next struct word. -*/
   strncpy(tbl_h-&gt;name,name,20);		/*- WARNING -*/
   memset((char*)(int(tbl_h-&gt;name)+strlen(name)),' ',
                20-strlen(name));
   strncpy(tbl_h-&gt;type,type,20);		/*- WARNING -*/
   memset((char*)(int(tbl_h-&gt;type)+strlen(type)),' ',
                20-strlen(type));

   tbl_h-&gt;maxlen = header.maxlen;
   tbl_h-&gt;nok = header.nok;
   tbl_h-&gt;rbytes = header.rbytes;
   tbl_h-&gt;dsl_pointer = (long)pT;
   tbl_h-&gt;data_pointer = (long)pData;
   tbl_d = pData;

   return TRUE;
}

/*
*:&gt;---------------------------------------------------------------------
*:ROUTINE:      tdm_nameMatch
*:DESCRIPTION:  
*:ARGUMENTS:    
*:ARGUMENTS:    
*:ARGUMENTS:    
*:RETURN VALUE: 
*:&lt;---------------------------------------------------------------------
*/
<B>int <A NAME="tdm_nameMatch">tdm_nameMatch(</A>char *a, char *b)</B>
{
   if( 0 == strcmp(a,b) ){
      return TRUE;
   }
   else {
      return FALSE;
   }
}

/*
*:&gt;---------------------------------------------------------------------
*:ROUTINE:	tdm_printCell
*:DESCRIPTION:	print a table cell
*:ARGUMENTS:	<A HREF="tdm_types.h.html#TDM_COLUMN_T">TDM_COLUMN_T</A> column
*:RETURN VALUE: 
*:&lt;---------------------------------------------------------------------
*/
<B>void <A NAME="tdm_printCell">tdm_printCell(</A>FILE *stream, <A HREF="tdm_types.h.html#TDM_CELLDATA_T">TDM_CELLDATA_T</A> *data</B>
		, <A HREF="tdm_types.h.html#TDM_COLUMN_T">TDM_COLUMN_T</A> *col)
{
   int i;
   int count = data-&gt;_length;

   if( data-&gt;_d != col-&gt;code ){
      fprintf(stream, "Data and column are inconsistant.\n");
      return;
   }
   fprintf(stream, " %s = \n", col-&gt;name);
   switch(col-&gt;code) {

   case DS_TYPE_CHAR:
      fprintf(stream, "\t%s", data-&gt;data.c);
      break;

   case DS_TYPE_OCTET:
      for (i = 0; i &lt; count; i++) {
	 fprintf(stream, "\t%u", data-&gt;data.o[i]);
      }
      break;

   case DS_TYPE_SHORT:
      for (i = 0; i &lt; count; i++) {
	 fprintf(stream, "\t%hd", data-&gt;data.s[i]);
      }
      break;

   case DS_TYPE_U_SHORT:
      for (i = 0; i &lt; count; i++) {
	 fprintf(stream, "\t%hu", data-&gt;data.us[i]);
      }
      break;

   case DS_TYPE_LONG:
      for (i = 0; i &lt; count; i++) {
	 fprintf(stream, "\t%ld", data-&gt;data.l[i]);
      }
      break;

   case DS_TYPE_U_LONG:
      for (i = 0; i &lt; count; i++) {
	 fprintf(stream, "\t%lu", data-&gt;data.ul[i]);
      }
      break;

   case DS_TYPE_FLOAT:
      for (i = 0; i &lt; count; i++) {
	 fprintf(stream, "\t%g", data-&gt;data.f[i]);
      }
      break;

   case DS_TYPE_DOUBLE:
      for (i = 0; i &lt; count; i++) {
	 fprintf(stream, "\t%g", data-&gt;data.d[i]);
      }
      break;

   case DS_TYPE_STRUCT:
      fprintf(stream, "Unable to print structs at this time.\n");
      break;

   default:
      fprintf(stream, "\tINVALID_TYPE");
      break;
   }
}

<P>
<P>
<HR>
<H2>Back to <A HREF="files.html">Source File Index</A></H2><P>
<P><HR>
<H5>C++ to HTML Conversion by <I><A HREF="http://www.usc.edu/dept/robotics/personal/af0a/tools/ctoohtml/ctoohtml.html">ctoohtml</A></I></H5>
















































</PRE>
</HTML>
