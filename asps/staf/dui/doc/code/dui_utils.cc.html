<HTML>
<PRE>
<H2>file: dui/src/dui_utils.cc</H2>


/*:Copyright 1996, Lawrence Berkeley National Laboratory
*:&gt;---------------------------------------------------------------------
*:FILE:         dui_utils.C
*:DESCRIPTION:  Functions for parsing and handling path names.
*:DESCRIPTION:  To compile as stand-alone test program:
*:DESCRIPTION:  	CC -DTEST dui_path.C -o dui_path
*:AUTHOR:       cet - Craig E. Tull, cetull@lbl.gov
*:BUGS:         -- STILL IN DEVELOPMENT --
*:HISTORY:      31jan96-v001b-cet- <A HREF="duiClasses.cc.html#mv">mv</A> dui_path.C dui_utils.C
*:HISTORY:      22jan96-v001a-cet- remove TEST code
*:HISTORY:      20nov95-v000a-cet- creation
*:&lt;---------------------------------------------------------------------
*/

/*-------------------------------------------- INCLUDES             --*/
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include "asuAlloc.h"
#include "<A HREF="dui_types.h.html">dui_types.h</A>"

/*-------------------------------------------- MACROS               --*/
/*-------------------------------------------- TYPEDEFS             --*/
/*-------------------------------------------- GLOBALS              --*/
/*-------------------------------------------- PROTOTYPES           --*/
#include "sutLib.h"

/*
*:&gt;---------------------------------------------------------------------
*:ROUTINE:      char * rootof
*:DESCRIPTION:  Find root of an absolute path
*:ARGUMENTS:    char * path	= path string (absolute)
*:RETURN VALUE: char * root	= root of path arg
*:&lt;---------------------------------------------------------------------
*/
<B>char * <A NAME="dui_rootof">dui_rootof(</A>const char* path)</B>
{
   return (char*)strntok(path,"/",0);
}

/*
*:&gt;---------------------------------------------------------------------
*:ROUTINE:      char * dirof
*:DESCRIPTION:  Find directory part of path
*:ARGUMENTS:    char * path	= path string (absolute)
*:RETURN VALUE: char * 		= directory part of path
*:&lt;---------------------------------------------------------------------
*/
<B>char * <A NAME="dui_dirof">dui_dirof(</A>const char* path)</B>
{
   char *d=NULL,*n,*p;
   int i=0;

   d=(char*)ASUALLOC(strlen(path)+1);
   d[0] = '\000';
   p=NULL;
   while( n = (char*)strntok(path,"/",i++) ){
      if(p){
         strcat(d,"/");
         strcat(d,p);
         ASUFREE(p);
      }
      p=(char*)n;
   }
   if(p)ASUFREE(p);
   return d;
}

/*
*:&gt;---------------------------------------------------------------------
*:ROUTINE:      char * notdirof
*:DESCRIPTION:  Find non-directory part of path
*:ARGUMENTS:    char * path	= path string (absolute)
*:RETURN VALUE: char * 		= non-directory part of path
*:&lt;---------------------------------------------------------------------
*/

<B>char * <A NAME="dui_notdirof">dui_notdirof(</A>const char * path)</B>
{
   char * c=NULL;
   char * p=NULL;
   int i=0;

   while( c = (char*)strntok(path,"/",i++) ){
      if(p)ASUFREE(p);
      p = (char*)c;
   }
   return p;
}

/*
*:&gt;---------------------------------------------------------------------
*:ROUTINE:      char * pathof
*:DESCRIPTION:  Construct absolute path from abs. base & rel. mod
*:ARGUMENTS:    char * base	= base path string (absolute)
*				= must be non-NULL
*:ARGUMENTS:    char * mod	= modifier path string (relative)
*:RETURN VALUE: char *	 	= parsed absolute path
*:&lt;---------------------------------------------------------------------
*/
<B>char * <A NAME="dui_pathof">dui_pathof(</A>const char* base,const char* mod)</B>
{
   char *p=NULL;
   if( NULL == strchr("/",base[0]) ){
      return NULL;	// base must be absolute path.
   }
   if( mod == NULL ){
      p = (char*)ASUALLOC(strlen(base)+1);
      strcpy(p,base);
      return p;		// bad mod
   }
   switch (mod[0]) {
   case '/':		// mod looks like an absolute path
      p = (char*)ASUALLOC(strlen(mod)+1);
      strcpy(p,mod);
      return p;
      break;
   default:		// mod looks like a relative path
   { //-for d[] scope
      char *d[128];	// max directory depth of 128
      int i=0;		// depth counter
      int l=0;		// string length
      while( d[i]=strntok(base,"/",i) ){	// load absolute base
         l += strlen(d[i]);
         i++;
      }
      int j=0;
      while( d[i]=strntok(mod,"/",j++) ){	// add relative mod
         if( 0 == strcmp("..",d[i]) ){
            ASUFREE(d[i--]);
            l -= strlen(d[i]);
            ASUFREE(d[i]);
         }
         else if( 0 == strcmp(".",d[i]) ){
            ASUFREE(d[i]);
         }
         else {
            l += strlen(d[i]);
            i++;
         }
      }
      char* ap = (char*)ASUALLOC(l+i+1);
      memset(ap,0,l+i+1);		//ap[0] = '\000';
      for( int k=0;k&lt;i;k++ ){
         strcat(ap,"/");
         strcat(ap,d[k]);
         ASUFREE(d[k]);
      }
      return ap;
      break;
   } //-for d[] scope
   }
}

/*
*:&gt;---------------------------------------------------------------------
*:ROUTINE:      int duiFindDS
*:DESCRIPTION:  Recursive search for DSL node within hierarchy.
*:DESCRIPTION:	** Should be a dsl function? **
*:ARGUMENTS:    DS_DATASET_T&* node	= dataset found (or NULL)
*:ARGUMENTS:    DS_DATASET_T* root	= root dataset
*:ARGUMENTS:    char* path		= Unix-like path
*:RETURN VALUE: TRUE or FALSE
*:&lt;---------------------------------------------------------------------
*/
<B>int <A NAME="duiFindDS">duiFindDS(</A>DS_DATASET_T *& node, DS_DATASET_T* root, char* path)</B>
{
   char *s;
   DS_DATASET_T *pDSr=root;
   DS_DATASET_T *pDSc=NULL;
   int i=0;
   char *name;
   bool_t isDataset;

   while( (s = strntok(path,"/",i++)) != NULL ){
   if( 0 != strcmp(s,pDSr-&gt;name)){ 	// ***** HACK *****
      if( !dsIsDataset(&isDataset,pDSr)
      ||  !isDataset
      ||  !dsFindEntry(&pDSc, pDSr, s)
      ){
	 dsPerror("can't find DSL node");
	 ASUFREE(s);
	 return FALSE;
      }
      ASUFREE(s);
      pDSr = pDSc;
   }
   }
   node = pDSr;
   return TRUE;
}

<P>
<P>
<HR>
<H2>Back to <A HREF="files.html">Source File Index</A></H2><P>
<P><HR>
<H5>C++ to HTML Conversion by <I><A HREF="http://www.usc.edu/dept/robotics/personal/af0a/tools/ctoohtml/ctoohtml.html">ctoohtml</A></I></H5>
















































</PRE>
</HTML>
