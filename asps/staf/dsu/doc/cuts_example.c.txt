/*
** Example code for using the table cuts and parsing mechanism of dsu.
** For your convenience:
**     1. This C file is free of globals.
**     2. The functions intended for your perusal [main(), TableCuts(),
**            and Parsing()] are well-commented.
** See Usage() for usage information.
** If you are interested in table cuts, look at the function TableCuts().
** If you are interested in parsing, look at the function Parsing().
*/
/***********************************************************  INCLUDES   **/
#include <stdio.h>
#include "/afs/rhic/star/starlib/ref/sys/dsl/inc/dstype.h"
#include "/afs/rhic/star/starlib/ref/sys/dsl/inc/dsxdr.h"
/***********************************************************  TYPEDEFS   **/
typedef int myBool;
/***********************************************************  DEFINES    **/
#define NBYTES 10000
/***********************************************************  PROTOTYPES **/
float dsuLevel1(char *expr,DS_DATASET_T *pTable,long row);
/***********************************************************  FUNCTIONS  **/
void Uerror(int x) {
  printf("There is a fatal cuts error.  Number %d.\n",x); exit(2);
}
void CreateDsPointer(char *fn,FILE **ff,XDR *xdr,DS_DATASET_T **dsPtr) {
  if ((*ff = fopen(fn, "rb")) == NULL) {
    printf("I cannot read \"%s\".  This should be a xdf file.\n",fn); exit(2);
  }
  xdrstdio_create(xdr, *ff, XDR_DECODE);
  if(!xdr_dataset(xdr,dsPtr)) Uerror(  3);
}
void GetTablePointer(DS_DATASET_T **tblPtrOut,DS_DATASET_T *dsPtr) {
  myBool isDataset,isTable; size_t scr,numEntries,entryNumber; char *name;
  char ans[5];
  DS_DATASET_T *local;
  if(!dsIsDataset(&isDataset,dsPtr))            Uerror(  4);
  if(!dsIsTable(&isTable,dsPtr))                Uerror(  5);
  if( isDataset&& isTable)                      Uerror(  1);
  if(!isDataset&&!isTable)                      Uerror(  2);
  if(isDataset) if(!dsDatasetName(&name,dsPtr)) Uerror(  9);
  if(isTable)   if(!dsTableName(&name,dsPtr))   Uerror( 10);
  if(isTable&&!(*tblPtrOut)) {
    printf("Do you want to use the table named \"%s\"? ",name);  gets(ans);
    if(*ans=='y') (*tblPtrOut)=dsPtr;
  }
  if(isDataset) {
    printf("In dataset %s.\n",name);
    if(!dsDatasetEntryCount(&numEntries,dsPtr)) Uerror(  8);
    for(entryNumber=0;entryNumber<numEntries;entryNumber++) {
      if(!dsDatasetEntry(&local,dsPtr,entryNumber)) Uerror(  6);
      GetTablePointer(tblPtrOut,local); /* recursive */
    }
  }
}
void Usage(char *argv) {
  printf("Usage:    %s myfile.xdf cutsOrParseString\n",argv);
  printf("Example:  %s file.xdf pid.eq.3.and.id/1000.le.9 # cuts\n",argv);
  printf("Example:  %s file.xdf (id*3)/(inpt+3.114)       # parsing\n",argv);
  exit(2);
}
void TableCuts(char *cutsString,DS_DATASET_T *tablePointer) {
  char ba[NBYTES]; size_t irow,numberOfRows;

  /* 
  ** STEP 1.  Create an array of chars whose number of 
  ** bits (BITS, NOT BYTES) is greater than the number
  ** of rows in the table.  You may want to use dynamic
  ** memory allocation instead of static as used here.
  */
  if(!dsTableRowCount(&numberOfRows,tablePointer)) Uerror(111);
  printf("The number of rows is %d.\n",numberOfRows);
  if(numberOfRows/8>NBYTES-2) Uerror(112);

  /* 
  ** STEP 2.  Call the API function which fills the array ba bitwise.
  */
  if(!dsuDoCuts(NBYTES,ba,cutsString,tablePointer)) Uerror(113);

  /*
  ** STEP 3.  Loop over the rows, using the second API function
  ** which reads the bit array for you.
  */
  for(irow=0;irow<numberOfRows;irow++) {
    if(dsuRowPassedCuts(ba,irow)) printf("Row # %d passed cuts.\n",irow+1);
  }
}
void Parsing(char *parseString,DS_DATASET_T *tablePointer) {

  int i;
  long rowNum;
  char ans[10];
  float result;

  /*
  ** Loop until user does control-c (interrupt) or enters non-positive
  ** row number.
  */
  for(;;) {

    for(i=0;i<80;i++) printf("-"); printf("\n");
    printf("Parse string = %s.\n",parseString);

    /*
    ** Get row number from user.
    */
    printf("Enter row number (count from 1, like FORTRAN):  "); gets(ans);
    rowNum=atoi(ans);
    if(rowNum<1) break;


    /*
    ** Call the single dsu api function involved.
    */
    result=dsuLevel1(parseString,tablePointer,rowNum-1);

    printf("The answer row %d is %g.\n",rowNum,result);

  }
}
void main(argc,argv) int argc; char **argv; {

  char *cutsOrParseString,*inputFile,didOne=FALSE,ans[10];
  int i;
  FILE *stream; 
  XDR xdr; 
  DS_DATASET_T *tablePointer=NULL,*dsPtr=NULL;

  /*
  ** Check usage and uses the command line args to set some 
  ** descriptively-named variables.
  */
  if( 
    ( argc==2 && (!strcmp(argv[1],"-h")||!strcmp(argv[1],"help") ) )
    ||
    ( argc!=3 ) 
  ) Usage((char*)argv[0]);
  inputFile=argv[1];
  cutsOrParseString=argv[2];

  /*
  ** Create a table pointer.
  */
  CreateDsPointer(inputFile,&stream,&xdr,&dsPtr);
  GetTablePointer(&tablePointer,dsPtr);
  if(tablePointer==NULL) { printf("No selection.\n"); exit(2); }

  /*
  ** Call the one of the two functions which use the dsu cuts api.
  */
  do {
    for(i=0;i<80;i++) printf("-"); printf("\n");
    printf("     c cuts\n");
    printf("     p parsing\n");
    printf("Enter either 'c' or 'p':  "); gets(ans);
    if(*ans=='c') { TableCuts(cutsOrParseString,tablePointer); didOne=TRUE; }
    if(*ans=='p') { Parsing(cutsOrParseString,tablePointer);   didOne=TRUE; }
  } while(!didOne);

  /*
  ** Wrap-up.
  */
  fclose(stream);
  return;
}
